Введение в тему
В новой теме вам предстоит узнать, что такое массивы и как с ними работать. Массив (англ. array) — это переменная, которая содержит несколько значений, относящихся к одному типу данных. В них удобно хранить большие объёмы однородных данных. 
В этой теме вы узнаете: 
в каких случаях лучше использовать массивы;
как создать проинициализированный массив с фиксированным набором значений;
что такое индекс массива и какие операции можно с ним проводить;
как узнать длину массива;
как заполнить массив значениями, используя цикл for;
как избежать ошибки выхода за границы массива.

Массивы: что это такое?
Массив (англ. array) — это базовая структура для хранения однотипных данных. Разберём, чем массив отличается от переменной и как работать с массивами. 
Переменная vs массив
Переменная в коде может хранить только одно значение. Это может быть число или строка. Чтобы работать с несколькими значениями, нужно объявить несколько переменных.  Например, чтобы использовать четыре разные валюты, нужно объявить четыре переменные. 

// объявляем все валюты по очереди
String usd = "USD"; // одна переменная — одна валюта
String eur = "EUR";
String jpy = "CNY";
String rub = "RUB";

System.out.println("Поддерживаемая валюта: " + usd);
System.out.println("Поддерживаемая валюта: " + eur);
System.out.println("Поддерживаемая валюта: " + cny);
System.out.println("Поддерживаемая валюта: " + rub); 
Получится:

Поддерживаемая валюта: USD
Поддерживаемая валюта: EUR
Поддерживаемая валюта: CNY
Поддерживаемая валюта: RUB 
Чтобы включить в этот список новые валюты, придётся создавать для каждой отдельную переменную. Это неудобно и долго, особенно если валют не четыре, а десятки или сотни. Кроме того, код станет громоздким и работать с ним будет непросто.
Массив — это переменная, которая содержит несколько значений, относящихся к одному типу данных. К примеру, если переменная с одним значением — это одна конфета, то массив — это коробка с конфетами. 

В массивах удобно хранить большие объёмы однородных данных. Например, список телефонных номеров или адресов, свод физических характеристик: роста или веса, перечень географических координат, список дат, расходы за определённый промежуток времени и многое другое. С массивами гораздо удобнее работать в коде, чем с разрозненными переменными. 
Разделите ситуации на две корзинки: где можно и нужно использовать массив и где — отдельные переменные.
Массив
Список валют
Список валют
История списаний средств с карты (без учёта даты и времени)
История списаний средств с карты (без учёта даты и времени)
Перечень данных о сотруднике, включающий его имя, возраст, должность и стаж
Перечень данных о сотруднике, включающий его имя, возраст, должность и стаж
Свод данных по расходам за электричество в квартире
Свод данных по расходам за электричество в квартире
Список фамилий студентов курса
Список фамилий студентов курса

Переменная
Курс доллара в банковском приложении
Курс доллара в банковском приложении
Баланс на банковской карте
Баланс на банковской карте

Правильных ответов: 6, неправильных ответов: 1. Вы ответили некорректно на карточку Перечень данных о сотруднике, включающий его имя, возраст, должность и стаж, комментарий к ответу: .
Как вам задача?


Как объявить массив
Объявление массива начинается с указания типа его значений. Массив хранит в себе значения только одного типа. Это может быть int, double, boolean, String или любой другой. Для хранения разных типов значений надо создавать разные массивы. Объединить, например, значения типов int и boolean в одном массиве не получится — потребуется создать два разных.  
После указания типа данных идут квадратные скобки [] — это визитная карточка, отличительный знак массива, затем указывается его имя. После оператора присваивания = происходит инициализация массива — заполнение его значениями. Все значения необходимо перечислить в фигурных скобках {} через запятую. Вот как будет выглядеть в коде массив для валют:

String[] currencies = {"USD", "EUR", "CNY", "RUB"}; 
Вместо четырёх переменных получилась одна переменная-массив. Массив называется currencies, хранит значения типа String (такой же тип был у переменных, которые он объединил) и содержит названия валют — доллара, евро, иены и рубля. 
Укажите варианты, где массив описан правильно.


int[] numbers = {1, 2.5 > 5, 3 < 4, 4.7};
Здесь есть и целые, и дробные, и логические значения, а массив может хранить только один тип данных. Новый тип данных — новый массив!

Правильный ответ
int[] numbers = {1};
Синтаксис верный, это массив. Массивы могут содержать только одно значение.

String currency = "USD";
Это не массив, это переменная типа string. Чтобы создать массив, нужны квадратные скобки [] после типа данных и фигурные {} для хранения значений.

int{} numbers = [1, 2, 3];
Здесь ошибка — использован неверный синтаксис. Скобки перепутаны местами: квадратные должны стоять после типа данных, а фигурные хранить значения.

Правильный ответ
String[] notes = {"До", "Ре", "Ми", "Фа", "Соль", "Ля", "Си"};
Абсолютно верно! Это массив с нотами.

int numbers = {1};
Некорректный синтаксис. Это и не переменная — стоят фигурные скобки, и не массив — забыты квадратные скобки [], которые так похожи на коробку для хранения!

String[] numbers = {1, "2", 3, "4"};
Здесь ошибка. Значения в массиве различаются по типу: внутри фигурных скобок собраны числа и строки. Тип массива String, значит, должны быть только строки.
Как вам задача?


В программировании вы будете работать с самыми разными массивами — короткими и длинными, содержащими строки, числа или другие данные. Пока вы будете сталкиваться в основном с массивами строк (String) или чисел (int, double и другими). Но в будущем сможете создавать массивы любых типов, в том числе и тех, которые будете описывать самостоятельно. При этом принципы работы с массивами останутся одинаковыми. А ещё массивы можно комбинировать — например, создавать массивы массивов (в математике такие структуры называются матрицами). Мы разберём это позже.

String[] allOfMyStrings = ...

long[][] matrixOfLong = ... 
Подробнее о различных вариациях массивов вы узнаете позже, в этой теме вам пригодится только обычный массив.

Учимся работать с массивами: индексы и элементы
Вы научились преобразовывать список однотипных переменных в единый массив, внутри которого теперь собраны все их значения. Однако массив был бы бесполезен, если бы с его данными нельзя было взаимодействовать. Как это делать, сейчас расскажем! 
Индексация массива
Если представить, что массив — это коробка со множеством отделений, то у каждого из этих отделений есть свой идентификационный номер. Как у почтовых ящиков в вашем подъезде. Чтобы взять письмо из ящика, нужно знать его номер.

Номер каждого почтового ящика в массиве называется индексом, а его содержимое — значение, которое там хранится — элементом. Если требуется извлечь из массива определённый элемент, надо указать его индекс. К примеру, на прошлом уроке мы создали массив с валютами:

String[] currencies = {"USD", "EUR", "CNY", "RUB"}; 
Чтобы получить конкретный элемент, нужно указать имя массива и индекс элемента в квадратных скобках.
Полученный элемент можно вывести на экран:

String[] currencies = {"USD", "EUR", "CNY", "RUB"};
System.out.println("Вы выбрали валюту: " + currencies[1]); 
Результат будет таким:

Вы выбрали валюту: EUR 
Индексация массива всегда начинается с нуля, а не с единицы. В нашем массиве из четырёх валют у доллара индекс будет 0, а у рубля — 3. А под индексом 1 хранятся евро.
Соотнесите понятие с его определением:
Тип данных, который хранит фиксированное количество однотипных значений.
Массив
Массив — это специальный тип данных для хранения однородных значений.
Одно из значений, хранящееся в массиве.
Элемент массива
Элемент массива — это одно из его значений.
Порядковый номер элемента массива.
Индекс
Индекс — это номер элемента.
Как вам задача?


Меняем значения элементов
Значение любого элемента в массиве можно изменить. Для этого сначала понадобится найти нужный элемент через его индекс (например, доллары —currencies[0]), а потом с помощью оператора присваивания = задать ему новое значение (пусть это будут швейцарские франки).

Можно заменить хоть все валюты, важно при обращении к ним не перепутать индексы:
Код

JAVA

1
class Practicum {
2
    public static void main(String[] args) {
3
        String[] currencies = {"USD","EUR","JPY","RUB"};
4
?
5
        // выводим список поддерживаемых валют
6
        System.out.println("Список поддерживаемых валют:");
7
        System.out.println(currencies[0]);
8
        System.out.println(currencies[1]);
9
        System.out.println(currencies[2]);
10
        System.out.println(currencies[3]);
11
?
12
        System.out.println("Не везде пригодятся: " + currencies[0]);
13
        currencies[0] = "CHF";
14
        System.out.println("В Швейцарии в обращении: " + currencies[0]);
15
?
16
        System.out.println("В Дании не примут: " + currencies[1]);
17
        currencies[1] = "DKK";
18
        System.out.println("Там нужны: " + currencies[1]);
19
?
20
        System.out.println("Зачем нам в Китае: " + currencies[2]);
21
        currencies[2] = "CNY";
22
        System.out.println("Купим: "+ currencies[2]);
23
?
24
        System.out.println("В Беларуси родные: " + currencies[3]);
25
        currencies[3] = "BYN";
26
        System.out.println("Поменяю на местные: " + currencies[3]);
27
?
28
        // теперь список поддерживаемых валют другой
29
        System.out.println("Новый список поддерживаемых валют:");
30
        System.out.println(currencies[0]);
31
        System.out.println(currencies[1]);
32
        System.out.println(currencies[2]);
33
        System.out.println(currencies[3]);
34
    }
35
}




Запустить код
Обновлённый массив выглядит так: {"CHF", "DKK", "CNY", "BYN"}. Все первоначальные элементы заменены на новые. В массиве есть швейцарские франки, датские кроны, китайские юани и белорусские рубли, а вот долларов, евро, иен и российских рублей больше нет. Поэкспериментируйте с кодом, выберите новые значения валют и замените значения элементов. 

Взаимодействуем с массивом через консоль
В прошлом уроке вы заменяли значения элементов внутри кода программы. Однако это можно сделать и через ввод внешних данных, например, с консоли.  
Представим, что пользователь — начинающий брокер. Он добавил в свой инвестиционный портфель (массив) четыре базовые валюты: доллары, евро, иены и рубли. Однако покупка иен на бирже сейчас недоступна. Попросим пользователя выбрать другую валюту и присвоим её значение элементу JPY :

String[] currencies = {"USD", "EUR", "JPY", "RUB"}; // Массив валют

Scanner scanner = new Scanner(System.in);
System.out.println("Покупка иен недоступна. Выберите другую валюту и введите её буквенный код:");

String userCurrency = scanner.next(); // Даём пользователю возможность ввести валюту
currencies[2] = userCurrency; // Присваиваем ввод пользователя элементу c индексом 2

System.out.println("Спасибо! Эта валюта в наличии.");
System.out.println("Мы заменили в вашем портфеле JPY на: " + currencies[2]); 
Сначала сохраняем ввод пользователя в переменную userCurrency, а затем присваиваем её значение нужному элементу — иенам. Его индекс 2, поэтому получится currencies[2] = userCurrency. Теперь значение элемента JPY будет меняться на усмотрение пользователя. 
Можно усложнить программу — дать пользователю возможность поменять не определённый элемент, а любой, который он захочет. Механика взаимодействия с массивом всегда одна и та же: сначала мы получаем элемент по его индексу, а потом присваиваем ему новое значение. Если мы сообщим индексы пользователю, он также сможет выбрать и заменить каждый из элементов. 

Длина массива
Создать массив легко, если его содержание заранее известно. Например, в массиве с валютами было определено и количество элементов — четыре, и значение каждого элемента. Так бывает не всегда. 
Представьте такую ситуацию: продюсер решил создать музыкальную группу и точно знает, что возьмёт четверых музыкантов. Выступление группы анонсировано — её уже обсуждают, но кастинг не проведён и конкретные исполнители не выбраны.
Аналогично в Java можно создать массив, в котором известно точное число элементов, но их конкретные значения не определены. Для этого нужно указать его размер.
Что такое размер массива
Размер, или длина (англ. length), массива — это количество элементов, которые он содержит. У массива всегда должен быть задан размер. После того как массив создан, изменить его размер невозможно. 
Если создаётся массив без значений, его размер указывается вручную — без этого ничего не получится. Если же значения всех элементов массива уже указаны в фигурных скобках, его длина будет задана автоматически и её можно будет вычислить по их количеству.
Создание массива через длину частично похоже на объявление массива с известными элементами. Сначала указывается тип данных, которые будут содержаться в массиве, квадратные скобки [] и название массива — например, String[] currencies. Однако после оператора присваивания = не будет фигурных скобок и перечисления элементов. Там используется ключевое слово new (англ. «новый»), ещё раз указывается тип значений будущих элементов и в квадратных скобках определяется размер массива: например, new String[4].

Ключевое слово new в Java используется достаточно часто — вы ещё не раз с ним встретитесь. Оно означает, что создаётся новое значение сложного типа. К сложным типам в Java относятся, например, уже знакомые вам scanner и генератор случайных чисел random. А такие типы, как int, double, boolean считаются примитивными, для создания их значения слово new не используется. 
Массивы в Java считаются сложным типом данных, поэтому для создания массива нужно использовать ключевое слово new. После того, как вы создали новый массив и определили его размер, можно наполнить его элементами. Для этого нужно вызвать каждый элемент по его индексу и присвоить ему содержание. С этим действием вы уже знакомы:

String[] currencies = new String[4]; // создан массив, в котором должно быть четыре валюты

currencies[0] = "USD"; // определили первую валюту, записали её в массив
// определили остальные валюты
currencies[1] = "EUR";
currencies[2] = "JPY";
currencies[3] = "RUB"; 
Присваивать значения элементам можно в любом порядке. Между объявлением массива и его пошаговой инициализацией могут быть другие операции или команды: например, вычисления или ввод значений элементов с консоли. Когда всем элементам массива присвоено значение, у вас получится такой же массив, как если бы он был инициализирован с помощью фигурных скобок.  
При работе с массивами важно знать некоторые особенности их построения в коде. К примеру, пустой массив нужной длины можно задать не только одной строкой, но и в два шага: 

String[] currencies = new String[4]; // можно задать массив так

// а можно так:
String[] currencies; // объявили переменную-массив, её ещё нельзя использовать
currencies = new String[4]; // массив готов к использованию, его элементы пока пусты

// далее заполняем массив значениями 
А вот создать массив с известными заранее значениями элементов можно только одной строкой — иначе произойдёт ошибка:


String[] currencies = {"USD", "EUR", "JPY", "RUB"}; // массив готов и проинициализирован

String[] currencies; // разбить на две строки не получится
currencies = {"USD", "EUR", "JPY", "RUB"}; // произойдёт ошибка 
 
Ещё раз поработаем со списком расходов. Создайте пустой массив с именем expenses, в нём должно быть место для трёх элементов. Задайте значения каждого из них. Пусть первая трата будет 100 рублей, вторая — 50 рублей, а третья — 200. Используйте тип данных double.
Код

JAVA

1
class Practicum {
2
    public static void main(String[] args) {
3
        double[] expenses = new double[3];// создайте массив
4
        expenses[0] = 100;
5
        // ниже задайте значения элементов массива
6
        expenses[1] = 50;
7
        expenses[2] = 200;
8
?
9
    }
10
}
Отлично! Теперь вы умеете объявлять массив, зная только его длину.


Подсказка





Проверить
Узнаём свойства массива
Представим, что в вашем распоряжении есть вот такой проинициализированный массив, размер которого нужно узнать:

String[] currencies = {"USD", "EUR", "JPY", "RUB", "THB", "UAH", "MAD", "SGD", "AMD", "DKK", "CZK", "SEK", "TRY", "KZT", "CHF"}; 
Считать длину массива вручную долго и неудобно. Кроме того, можно легко ошибиться. Вычислить количество элементов можно с помощью свойства массива length (англ. «длина»).
В окружающем нас мире у всех объектов есть свои свойства: у красок — цвет, у автомобилей — мощность, у котов — вредность и пушистость. У программных составляющих сложных типов (сканера, массива и других) тоже есть свойства — с их помощью можно получить нужную информацию о них. В частности, узнать длину массива можно, обратившись к его свойству length. Механика проста: имя_массива.length.
Код

JAVA

1
class Practicum {
2
    public static void main(String[] args) {
3
        String[] currencies = {"USD", "EUR", "JPY","USD", "EUR", "JPY", "THB", "UAH", "MAD", "SGD", "AMD", "DKK", "CZK", "SEK", "TRY", "KZT", "CHF"};
4
        int currenciesCount; // В этой переменной будет храниться размер массива currencies
5
        currenciesCount = currencies.length; // Обращаемся к свойству length через имя массива и точку
6
?
7
        System.out.println("Сколько валют в приложении?");
8
        System.out.println(currenciesCount); // Печатаем результат
9
    }
10
}




Запустить код
В результате выполнения программы мы узнаем, что всего в массиве 15 элементов. Добавьте в него или удалите из него значения валют и посмотрите, как изменится его длина.
?? Способ создания массива не влияет на его свойства, поэтому получить длину через length можно и тогда, когда она задаётся заранее (при создании массива через new).
Ура! Массивы совсем не так страшны, как могло показаться в начале. Их размер легко вычислить, и вы точно знаете, как создать массив нужной длины, даже если кастинг его элементов ещё не проведён!
Выберите верные утверждения о длине массива:


Правильный ответ
Каждый массив имеет фиксированный размер
Верно, размер указывается при создании массива и не меняется в ходе работы с ним.

Размер массива может меняться после создания
Размер массива нельзя изменить после создания.

Неправильный ответ
Размер массива всегда нужно указывать при его создании
Это неверно: если при создании массива были указаны значения его элементов — длина массива будет задана автоматически.

Правильный ответ
Если создать массив с помощью фигурных скобок {}, его длина будет задана автоматически
Верно, в этом случае длина будет равна количеству элементов в фигурных скобках.

Правильный ответ
Длину массива можно узнать с помощью свойства length
В точку! Это свойство доступно и при создании массива через new, и через синтаксис с фигурными скобками.

Если массив создан через new, его длину нельзя узнать с помощью свойства length
Свойство length доступно у любого массива вне зависимости от способа его создания.
Как вам задача?


В массиве трат появилось много новых элементов. Посчитайте их общее количество и напечатайте, сколько получилось.
Код

JAVA

class Practicum {
    public static void main(String[] args) {
        double[] expenses = {100.50, 500.00, 10.00, 0.0, 40.60, 500.10, 200.00, 0.0, 50.10, 14.65, 5.10, 11.0};

        System.out.println("Сколько всего записей о расходах?");
        // Посчитайте размер массива
        int recordsCount = expenses.length;
        // Напечатайте полученный результат
        System.out.println(recordsCount);
    }
}
1
class Practicum {
2
    public static void main(String[] args) {
3
        double[] expenses = {100.50, 500.00, 10.00, 0.0, 40.60, 500.10, 200.00, 0.0, 50.10, 14.65, 5.10, 11.0};
4
?
5
        System.out.println("Сколько всего записей о расходах?");
6
        // Посчитайте размер массива
7
        int recordsCount = expenses.length;
8
        // Напечатайте полученный результат
9
        System.out.println(recordsCount);
10
    }
11
}

Массивы и циклы
В этой теме вы много работаете с массивом валют, и вам не раз нужно было напечатать его элементы. Чтобы это сделать, приходилось использовать в коде несколько однотипных строк:

String[] currencies = {"USD", "EUR", "JPY", "RUB"};
System.out.println("Поддерживаемая валюта: " + currencies[0]);
System.out.println("Поддерживаемая валюта: " + currencies[1]);
System.out.println("Поддерживаемая валюта: " + currencies[2]);
System.out.println("Поддерживаемая валюта: " + currencies[3]) 
Результат этого кода вы тоже много раз видели:

Поддерживаемая валюта: USD
Поддерживаемая валюта: EUR
Поддерживаемая валюта: JPY
Поддерживаемая валюта: RUB 
Однако если массив будет состоять не из четырёх, а из ста элементов, то придётся напечатать целых сто похожих строк кода! Но много повторяющегося кода это моветон. Вы же помните правило — Don't Repeat Yourself!
Выберите, какой инструмент лучше всего поможет избежать повторения кода при выводе элементов массива?


Ветвление if-else
Придётся написать очень сложное, громоздкое и неудобное ветвление — это только ухудшит ваш код.

Конкатенация
Конкатенация, сложение строк, не поможет избежать повторения кода.

Правильный ответ
Цикл for
Верно! Цикл for уже не раз помогал вам избежать дублирования кода. Именно он вам и нужен, ведь количество итераций известно заранее.

Метод equals
Метод equals() служит для сравнения значений строк и никак не поможет избежать повторения кода.

Цикл while
Размер массива (число его элементов) заведомо определяет количество итераций, значит, нужен цикл for.
Как вам задача?


Задаём условия работы цикла
Чаще всего для работы с массивами используется цикл for. Это логично, ведь число элементов массива (его размер) — это и есть число будущих итераций цикла, и оно известно заранее. 
Для того чтобы напечатать все элементы массива, вызовем их по очереди с помощью переменной итерирования — поставим её на место индекса. Цикл будет начинаться с нуля, так как ноль — стартовый индекс в любом массиве. Шаг цикла сделаем равным единице: так мы не пропустим ни одного элемента. 
Цикл должен работать до тех пор, пока не напечатаны все значения массива. Чтобы задать это условие, потребуется указать длину массива — получим её с помощью свойства length. Всё вместе в коде это будет выглядеть так:
Код

JAVA

1
class Practicum {
2
    public static void main(String[] args) {
3
        String[] currencies = {"USD", "EUR", "JPY", "RUB"}; // массив
4
// цикл начинается с 0 и продолжается c шагом в единицу, пока i строго меньше длины массива
5
        for (int i = 0; i <= currencies.length - 1; i++) {
6
// переменная итерирования ставится на место индекса, так все элементы будут напечатаны
7
            System.out.println("Поддерживаемая валюта: " + currencies[i]);
8
        }
9
    }
10
}




Запустить код
Обратите внимание, что индекс последнего элемента всегда на единицу меньше длины массива. К примеру, в массиве из четырёх элементов индекс последнего будет 3. Поэтому в условии цикла обычно используется знак строгого сравнения — i < currencies.length.
Можно задать условие работы цикла и через знак нестрогого сравнения «меньше или равно» <=. Нужно просто не забыть отнять от длины массива единицу. Попробуйте сделать это и убедитесь, что результат не изменится. 
Результат работы программы при использовании цикла останется таким же, как и при дублировании строк. Но теперь код будет выглядеть корректно, особенно если массив станет больше. 

Выход за границы массива
Вы уже немало знаете о массивах — умеете их создавать, получать их элементы по индексу и присваивать им новое значение. Отлично усвоили, что нумерация в массиве начинается с нуля, а его размер всегда задаётся в момент создания. Осталось разобраться, что произойдёт, если попытаться вызвать элемент массива за пределами его длины. Например, попробуем запросить пятый элемент из массива с четырьмя валютами:

class Practicum {
    public static void main(String[] args) {
        // 4 валюты, их индексы в массиве — от 0 до 3
        String[] currencies = {"USD", "EUR", "JPY", "RUB"}; 
        int index = 4;
        System.out.println(currencies[index]); // пытаемся получить элемент с индексом 4 
    }
} 
Если попробовать запустить этот код, то в консоли появится следующее сообщение об ошибке:

Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: Index 4 out of bounds for length 4
    at Practicum.main(Practicum.java:5) 
Первое слово в сообщении Exception, значит, произошло исключение. Оно называется ArrayIndexOutOfBoundsException, что означает «ошибка выхода за границы массива». Границы массива программа определяет как 0 и length - 1 — длина минус единица. Указанное исключение произойдёт, если в качестве индекса использовались числа меньше нуля и больше длины, то есть за пределами границ.
Выберите все номера строк, в которых произойдёт ошибка выхода за границы массива.

String[] currencies = {"USD", "EUR", "JPY", "RUB"}; // 1
// 2
int index = -1;// 3
System.out.println(currencies[index]); // 4
// 5
for (int i = 0; i <= currencies.length; i++) { // 6
    System.out.println(currencies[i]); // 7
} // 8
// 9
for (int i = 0; i < currencies.length; i++) { // 10
    System.out.println(currencies[i]); // 11
} // 12
// 13
int index = 7;// 14
System.out.println(currencies[index]);// 15 


Правильный ответ
4
Верно! Индекса -1 нет в массиве.

11
В этой строке ошибки не будет — цикл работает с массивом корректно.

14
В этой строке нет ошибки — это всего лишь присвоение значения переменной.

Правильный ответ
7
В этой строке произойдёт ошибка — в массиве нет элемента с индексом, равным длине массива.

6
В этой строке ошибки не произойдёт — для цикла нет никакой разницы, какие границы и шаг ему заданы.

Правильный ответ
15
Будет ошибка — в массиве размером 4 максимальный индекс равен 3.
Как вам задача?


Выход за границы массива — частая ошибка при вводе индекса пользователем. Возьмём традиционный пример с массивом из четырёх валют, где мы просим пользователя выбрать одну из них:

String[] currencies = {"USD", "EUR", "JPY", "RUB"};
Scanner scanner = new Scanner(System.in);

System.out.println("Введите индекс валюты, которую хотите напечатать, от 0 до 3:");
int index = scanner.nextInt(); // считываем ввод пользователя 

System.out.println("Поддерживаемая валюта: " + currencies[index]); 
Если пользователь выберет любое число меньше нуля или больше трёх, то в консоли появится сообщение с ArrayIndexOutOfBoundsException. 
Ошибки выхода за границы массива можно избежать с помощью ветвления. Конструкция с условными выражениями позволит проверить, подходит ли введённый пользователем индекс для получения элемента из массива:

String[] currencies = {"USD", "EUR", "JPY", "RUB"};

Scanner scanner = new Scanner(System.in);
System.out.println("Введите номер валюты, которую хотите купить:");
int index = scanner.nextInt(); // даём пользователю ввести индекс и считываем его ввод

if (index < 0) {
    // если индекс меньше 0, сообщаем пользователю об ошибке
    System.out.println("Неверное значение номера валюты! Выберите число от 0 до 3.");
} else if (index >= currencies.length) {
    // индекс должен быть строго меньше длины массива
    System.out.println("Неверное значение номера валюты! Выберите число от 0 до 3.");
} else {
    // всё хорошо, выводим запрошенную пользователем валюту
    System.out.println("Вы купили валюту: " + currencies[index]);
} 
Теперь при выборе индекса за границами массива программа не перестанет работать, а пользователь получит корректное сообщение об ошибке.

Добавляем операции с тратами в приложение
Код итогового проекта — финансового приложения — уже достаточно объёмный: оно многое умеет. Прежде чем мы перейдём к тому, чтобы расширить его возможности с помощью массивов, вспомним, из каких смысловых частей состоит программа и каков функционал каждой из этих частей.
Код ниже — это скелет вашего финансового приложения. Укажите, что он делает.

while (true) {
    ...
    int command = scanner.nextInt();

    if (command == 1) {
        ...
    } else if (command == 2) {
        ...
    } else if (command == 0) {
        System.out.println("Выход");
        break;
    } else {
        System.out.println("Извините, такой команды пока нет.");
    }
} 


Этот код запускает бесконечный цикл — финансовое приложение может работать без перерывов.
Бесконечный цикл даёт возможность бесчисленное количество раз переходить от одной команды к другой, но этот код нужен в первую очередь, чтобы обеспечить выполнение этих команд.

Правильный ответ
Этот код считывает и обрабатывает выбранный пользователем пункт меню.
Верно! Сейчас финансовое приложение умеет по выбору пользователя выполнять три команды: «Конвертировать валюту», «Получить совет» и «Выход».

Это ветвление, с помощью которого сбережения конвертируются в различные валюты.
Для конвертации в программе используется другое ветвление. Эта условная конструкция нужна для обработки главных команд приложения. Их три: «Конвертировать валюту», «Получить совет» и «Выход».

Этот код выводит остаток средств.
Такую команду приложение ещё не знает.
Как вам задача?


Теперь прочитайте этот фрагмент кода финансового приложения. За что он отвечает?

System.out.println("В какую валюту хотите конвертировать? Доступные варианты: 1 - USD, 2 - EUR или 3 - CNY.");
int currency = scanner.nextInt();

if (currency == 1) {
    System.out.println("Ваши сбережения в долларах: " + moneyBeforeSalary / rateUSD);
} else if (currency == 2) {
    System.out.println("Ваши сбережения в евро: " + moneyBeforeSalary / rateEUR);
} else if (currency == 3) {
    System.out.println("Ваши сбережения в юанях: " + moneyBeforeSalary / rateCNY);
} else {
    System.out.println("Введена неизвестная валюта.");
} 


Этот код выводит цифровое меню с тремя командами
Код предлагает пользователю на выбор варианты валют для конвертации, а не команды.

Правильный ответ
Этот код конвертирует сбережения пользователя в выбранную им валюту
Всё так, приложение умеет конвертировать рублёвый остаток зарплаты пользователя в одну из трёх валют на выбор — доллары, евро или юани.

Этот код даёт совет, в какую валюту конвертировать сбережения
Такого наше приложение делать не умеет.
Как вам задача?


Здесь упоминается что-то про ужин, ресторан и тягостное ожидание зарплаты. Для чего нужен этот многословный фрагмент кода? 

if (moneyBeforeSalary < 3000) {
    System.out.println("Сегодня лучше поесть дома. Экономьте, и вы дотянете до зарплаты!");
} else if (moneyBeforeSalary < 10000){
    if (daysBeforeSalary < 10) {
        System.out.println("Можно заказать пиццу!");
    } else {
        System.out.println("Сегодня лучше поесть дома. Экономьте, и вы дотянете до зарплаты!");
    }
} else if (moneyBeforeSalary < 30000) {
    if (daysBeforeSalary < 10) {
        System.out.println("Неплохо! Сегодня можно поужинать в кафе. :)");
    } else {
        System.out.println("Можно заказать пиццу!");
    }
} else {
    if (daysBeforeSalary < 10) {
        System.out.println("Отлично! Можно сходить в ресторан.");
    } else {
        System.out.println("Неплохо! Сегодня можно поужинать в кафе. :)");
    }
} 


Этот код сообщает число дней до зарплаты и остаток денег на счету
Этот код нужен, чтобы дать пользователю совет о том, на что хватит его сбережений.

Этот код конвертирует сбережения в выбранный пользователем ужин
Код сопоставляет состояние счёта с числом дней до зарплаты и даёт совет.

Правильный ответ
Этот код даёт совет исходя из размера сбережений
Верно! В зависимости от остатка на счёте пользователя и числа дней до зарплаты приложение подсказывает, стоит ли поесть дома или отведать морских деликатесов!
Что вы узнали
Ура! Вы прошли ещё одну непростую тему. Теперь вы знаете, что массивы широко используются в программировании для хранения и обработки большого количества данных. Это одна из основных структур данных, которая необходима для понимания многих алгоритмов. Подведём итоги и рассмотрим, какие знания вы получили: 
Массив хранит в себе значения только одного типа: int, double, boolean, String или любой другой.
Чтобы указать значения массива после его объявления, необходимо перечислить их
в фигурных скобках {}.
Индекс — номер элемента в массиве. Чтобы извлечь из массива определённый элемент,
надо указать его индекс — currencies[0].
Индексация массива начинается не с единицы, а с нуля.
Тип значения индекса элемента в массиве всегда int, а тип самого элемента массива
может быть любым.
Размер, или длина, массива — это количество элементов, которые он содержит.
У массива всегда должен быть задан размер, а после того как массив создан, изменить его размер невозможно.
Используя ключевое слово new, можно явно указать длину массива и разделить
объявление и инициализацию.
Для работы с массивами используют цикл for, так как число элементов массива — это и есть число будущих итераций цикла, и оно известно заранее.

Введение в тему
В новой теме вы изучите арифметические операции. С некоторыми из них вы уже работали в вводном курсе. Напомним, что арифметические операции в Java нужны для выполнения математических операций, таких как сложение, вычитание, умножение и деление. 
Арифметические операции могут использоваться для вычисления значений переменных, выполнения математических выражений и проверки условий в логических операциях.
В этой теме вы узнаете: 
как составлять алгоритм из нескольких простых выражений;
что такое полная и сокращённая запись с операторами и как использовать в коде сокращённую запись;
как определить, какой тип данных получится в результате арифметических операций;
что такое инкремент и декремент и каких видов они бывают.

Арифметические операции
В вводном курсе вы уже работали с арифметическими операциями сложения, вычитания, умножения, деления. В коде они записываются так:

        a = b + c; // сложение
        a = b - c; // вычитание
        a = b * c; // умножение
        a = b / c; // деление 
Знаки в выражениях: + , -, * и / — в программировании называют операторами, а аргументы выражений: переменные b и c — операндами. 
Чтобы правильно составить арифметическое выражение из нескольких операций, нужно понимать, в каком порядке они будут выполняться. 
Порядок выполнения арифметических операций в программировании основывается на математических правилах:
Сначала выполняются умножение и деление.
Затем — сложение и вычитание.
Действия в скобках выполняются первыми.
Считаем всегда слева направо.
Какое значение переменной result будет выведено на экран?

class Practicum {
    public static void main(String[] args) {
        int a = 15;
        int b = 10;

        int result = a + b * 2 / (2 + 2) - 1;
        System.out.println(result);
    }
} 
Ваш ответ правильный

19

19

Как вам задача?


Сначала выполняется сложение в скобках: (2+2)=4. Затем слева направо: умножение b * 2 (10?2=20) и деление 20/4=5. После этого слева направо: сложение a + 5 (15+5=20) и вычитание 20?1=19. Результат равен 19. 
Сокращённая запись
Результат операции можно сохранять в переменную, которая входит в арифметическое выражение. Например, здесь переменная a выступает и как результат, и как одно из слагаемых:

int a = 37;
int b = 9;
a = a + b; // в переменную a сохраняется результат, она же - одно из слагаемых
 
В таком случае лучше использовать сокращённую запись с оператором +=:

int a = 37;
int b = 9;
a += b; // то же самое, что и a = a + b, применён оператор +=
 
Сокращённо можно записать и другие операции:

int a = 36;
int b = 2;
a -= b; // равнозначно a = a - b, оператор -=
a *= b; // равнозначно a = a * b, оператор *=
a /= b; // равнозначно a = a / b, оператор /= 
Какой результат будет записан в переменную x после выполнения операции
x *= 3, если x = 5?
Ваш ответ правильный

15

Операция x *= 3 идентична операции x = x * 3. Правильный ответ 15.

Как вам задача?


Важное правило: без предварительного объявления переменной сокращённую запись использовать не получится.

int b = 9;
int a *= b; // в этом месте ошибка, переменная a должна быть объявлена заранее 
Исправьте код: расставьте строки так, чтобы программа напечатала число 57.
Код

JAVA

1
public class Practicum {
2
    public static void main(String[] args) {
3
       int b = 9;
4
      b /= 3;
5
int a = 11;
6
?
7
         a += 1;
8
        a *= 5;
9
       
10
         int result = a - b;
11
        System.out.println(result);
12
      
13
    }
14
}
Отлично! С помощью арифметических выражений можно легко получать нужные значения, а операторы помогут быстро производить вычисления.


Подсказка





Проверить
Остаток от деления
Ещё одна распространённая арифметическая операция в программировании — получение остатка от деления. Представьте, курьер привёз пиццу из семи кусочков для компании из трёх человек. Каждый съел по два кусочка, в коробке остался один ничейный — это и есть остаток от деления.

В коде получение остатка от деления обозначается операторами % и %=:
Код

JAVA

1
public class Practicum {
2
    public static void main(String[]args){
3
        int a;
4
        int b = 120;
5
        int c = 50;
6
        a = b % c; // остаток от деления 120 на 50 равен 20
7
        System.out.println(a);
8
        int d = 3;
9
        a %= d; // сокращённая запись для a = a % d; остаток от деления 20 на 3 равен 2
10
        System.out.println(a);
11
    }
12
}




Запустить код
Сначала переменная a будет равна 20, то есть в 120 вмещается два раза по 50 и ещё остаётся 20. Остаток от деления a на d будет равен 2, то есть в 20 содержится шесть раз по 3 и ещё остаётся 2. В виде формулы это выглядит так:

Остаток от деления может быть равен нулю. Например, так как 100 делится на 10 без остатка, в a сохранится 0:
Код

JAVA

1
?
2
public class Practicum {
3
    public static void main(String[]args){
4
        int a = 100;
5
        a %= 10;
6
        System.out.println(a);
7
    }
8
}




Запустить код
С помощью проверки остатка от деления можно понять, является ли одно число делителем другого. Это может пригодиться в решении некоторых задач. Например, если остаток от деления на 2 равен нулю, то число чётное.
Допишите условное выражение в main, которое будет проверять, чётное число или нет.
Код

JAVA

1
public class Practicum {
2
    public static void main(String[] args) {
3
        int numberToCheck = 11;
4
        if (numberToCheck%2 == 0) { // в условии должна быть проверка на чётность
5
            System.out.println(numberToCheck + " - чётное");
6
        } else {
7
            System.out.println(numberToCheck + " - нечётное");
8
        }
9
    }
10
}
Отлично! Теперь вы легко сможете выяснить, чётное перед вами число или нет.


Подсказка





Проверить
Остаток от деления можно вычислить и в тех случаях, когда делимое меньше делителя. В таких ситуациях остаток будет равен делимому.
Код

JAVA

1
public class Practicum {
2
  public static void main(String[] args) {
3
    int x = 14;
4
    int y = 20;
5
    int z = x % y;
6
    System.out.println(z);
7
  }
8
}




Запустить код
Логика вычислений такая: в 14 никак не поместится 20, то есть при делении нацело будет ноль. Поэтому остаток от деления получится равным 14. Применяйте это правило вместе с целочисленным делением и это позволит вам избежать ошибок деления на ноль, например в задачах масштабирования изображений или при построении статистических отчётов.
Чему равно значение переменной d?

int a = 25 % 5;
int b = 16 % 3;
int c = 17 % 20;
int d = a + b + c;
d /= 2 
Ваш ответ правильный

9

Как вам задача?


Последний кусочек пиццы ваш! Вы отлично усвоили, что такое остаток от деления!
При написании кода вам не раз придётся работать с арифметическими выражениями. Операция вычисления остатка от деления кажется сложной только на первый взгляд — на самом деле она ничем не отличаются от сложения или деления.

Целые и дробные числа в арифметических выражениях
Все арифметические операции можно производить как с целыми, так и с дробными числами. Например, можно рассчитать остаток от деления двух дробных чисел:
Код

JAVA

1
public class Practicum {
2
  public static void main(String[] args) {
3
    double b = 120.75;
4
        double c = 50.25;
5
        b %= c;
6
    System.out.println(b);
7
  }
8
}




Запустить код
Логика такая же, как и при работе с целыми числами: в 120.75 два раза помещается 50.25 и ещё остаётся 20.25. Это и есть искомый остаток от деления.
Что будет выведено на экран?

double b = 16.5 / 2.5;
double a = 1.0;
a = b / 2;
System.out.println(a + 1); 


1.0
В переменную b сохранится значение 6.6, затем a будет присвоено значение 3.3, а до печати прибавится ещё единица.

Правильный ответ
4.3
Арифметические операции с дробными типами ничем не отличаются от операций с целочисленными.

3.3
До печати к значению a будет прибавлена ещё единица: a + 1.

6.6
Это значение переменной b, а в консоли будет напечатано конечное значение переменной a.
Как вам задача?


При операциях с дробными типами в результате получается дробное число, при работе с целочисленными типами — результат тоже будет целочисленным.
Код

JAVA

1
public class Practicum {
2
    public static void main(String[] args) {
3
        int b = 120;
4
        int c = 43;
5
        b /= c;
6
        System.out.println(b);
7
    }
8
}




Запустить код
В консоли будет напечатано 2, а не 2.79. Переменная b, в которую сохраняется результат, имеет тип int, поэтому в неё сохранится целое число. При этом Java не округляет до целого, а отбрасывает все знаки после запятой. 
Сохраним остаток от деления в переменную типа double и посмотрим, удастся ли получить дробный ответ:
Код

JAVA

1
public class Practicum {
2
    public static void main(String[] args) {
3
        int b = 120;
4
        int c = 43;
5
        double a = b / c;
6
        System.out.println(a); // Получится 2.0, а не 2.79
7
    }
8
}




Запустить код
Получилось целое число в дробной записи: 2.0. Всё потому, что если операнды — целые, то Java снова отбросит все знаки после запятой. Если же хотя бы одна из переменных будет с плавающей точкой, то удастся добиться искомого результата:
Код

JAVA

1
public class Practicum {
2
    public static void main(String[] args) {
3
        int b = 120;
4
        int c = 43;
5
        double a = b / c;
6
        System.out.println(a); // Теперь получим нужный результат
7
    }
8
}




Запустить код
Когда в арифметическом выражении есть дробное число, то результат всегда будет дробным. При этом неважно, где именно используется переменная с плавающей точкой — это может быть делитель, множитель или слагаемое:
Код

JAVA

1
public class Practicum {
2
    public static void main(String[] args) {
3
        double x = 120;
4
        int y = 50;
5
        System.out.println(x + y);
6
?
7
        double l = 97.45;
8
        int m = 15;
9
        System.out.println(l - m);
10
?
11
        double b = 120.5;
12
        int c = 43;
13
        System.out.println(b * c);
14
    }
15
}




Запустить код
Если Java не знает, каким будет результат операции — целым (170) или дробным (82.45) числом, то сохраняет результат в дробном виде. Это нужно, чтобы никакая информация не потерялась.
Что будет выведено на экран?

int a = 24;
double b = a / 5;
System.out.println(b % 2.5); 


2.3
В переменную b сохранится значение 4.0, потому что мы работаем со значением типа int. Остаток от деления 4.0 на 2.5 равен 1.5.

4.0
Это значение b после деления a на 5. Ещё нужно посчитать остаток от деления на 2.5.

Правильный ответ
1.5
Остаток от деления 4.0 на 2.5 равен 1.5.

4.8
В переменную b сохранится значение 4.0, а не 4.8.
Как вам задача?


Если в выражении есть дробное число, то его результат нельзя сохранить в целочисленную переменную:
Код

JAVA

1
public class Practicum {
2
    public static void main(String[] args) {
3
        double x = 120;
4
        int y = 50;
5
        int z = x + y; // Здесь произойдёт ошибка
6
        System.out.println(z);
7
    }
8
}
submission/Practicum.java:5: error: incompatible types: possible lossy conversion from double to int
int z = x + y; // Здесь произойдёт ошибка
^
1 error





Запустить код
Это ошибка несовместимости типов. Дробное число нельзя привести к целому без потерь, поэтому программа не сможет этого сделать.
Посчитайте конечное значение b. 

int a = 11;
double b = 20.5;
a /= 2;
b %= a;
System.out.println(b); 
Ваш ответ неправильный

4.1

Выражение a /= 2 идентично выражению a = a / 2, а выражение b %= a можно развернуть в b = b % a. Учтите, что переменная a имеет тип int, а переменная b — тип double.

Операторы инкремента и декремента
При создании циклов вам часто приходилось увеличивать или уменьшать переменную итерирования на единицу:

for (int i = 1; i < 10 ; i = i + 1) {
    System.out.println("Этаж " + i);
}
for (int i = 10; i > 0 ; i = i - 1) {
    System.out.println("Этаж " + i);
} 
Теперь вы знаете, что эти операции можно записать ещё и вот так:

i += 1; 
i -= 1;  
Однако с помощью операторов ++ и -- эти выражения можно записать ещё короче:

i++;
i--;  
Запись i++ или i-- может быть альтернативой для i = i + 1 или i = i - 1. Но это упрощение. У выражений с ++ и -- есть и другие важные особенности. 
Операция, увеличивающая переменную на единицу, называется инкрементом (от англ. increase — «увеличивать»), а операция, уменьшающая переменную на единицу — декрементом (англ. decrease — «уменьшать»). Соответственно, ++ и -- называются операторами инкремента и декремента. Их можно записать как после переменной, так и перед ней:

++i;
--i;  
Запись операторов инкремента и декремента после переменной называют «постфиксной», а до — «префиксной». 
Выбор записи определяет порядок выполнения действий в коде. Префиксные операции всегда выполняются первыми в строке:
Код

JAVA

1
public class Practicum {
2
    public static void main(String[] args) {
3
        int prefix = 20;
4
        System.out.println(prefix);   // здесь значение равно 20
5
        System.out.println(++prefix); // значение сначала станет 21, а потом будет напечатано   
6
    }
7
}




Запустить код
В последней строке сначала сработает префиксная операция инкремента: изменится значение переменной prefix, и только потом оно будет напечатано. В результате в консоли появится число 21. 
Постфиксные операции инкремента и декремента, наоборот, выполняются после других действий в строке:
Код

JAVA

1
public class Practicum {
2
    public static void main(String[] args) {
3
        int postfix = 10;
4
        System.out.println(postfix);   // значение равно 10
5
        System.out.println(++postfix); // сначала будет напечатано 10, потом прибавится единица
6
        System.out.println(postfix);   // значение postfix теперь равно 11
7
    }
8
}




Запустить код
Постфиксный инкремент сработает уже после того, как значение postfix напечатается. Поэтому в консоли во второй строке будет 10, а не 11. Во всех следующих командах будет использоваться уже новое значение. Измените запись инкремента на префиксную и посмотрите, что напечатает программа.
Хьюстон, у нас проблемы! Сломался алгоритм обратного отсчёта на ракете SpaceY! Из центра управления есть доступ только к одной строке кода — строке печати в теле цикла. Исправьте её так, чтобы в консоли появились числа от 7 до 1.
Код

JAVA

1
public class Practicum {
2
    public static void main(String[] args) {
3
        int countDown = 8;
4
        for (int i = 0; i < 7; i++) {
5
            System.out.println(--countDown); // Исправьте эту строку
6
        }
7
        System.out.println("Вперёд!");
8
    }
9
}
Супер! Не забывайте про расположение операторов инкремента и декремента — это может помочь в вычислениях.


Подсказка





Проверить
Порядок вычислений
При составлении арифметического выражения в коде нельзя ограничиться только математическими правилами. Нужно также учитывать порядок выполнения операторов инкремента и декремента. Поэтому правила выполнения вычислений в Java можно сформулировать так:
Первыми отработают операторы префиксного инкремента и декремента: ++a и --a;
Затем — операторы умножения, деления и остатка от деления: *, / и %;
Третьи на очереди — операторы сложения и вычитания + и -;
Последними выполняются операции с постфиксным инкрементом и декрементом: a++ и a--.
Порядок расположения операторов в коде не отменяет математических правил о том, что вычисления выполняются слева направо, а операции в скобках имеют больший приоритет в сравнении с остальными и выполняются первыми. Рассмотрим на примере:

int a = 12;
int b = 4;
int d = --a % b + 5 * 4 + b++; 
Сначала выполнится префиксный декремент (--a), теперь a = 11. Следующим шагом будет взятие остатка: 11 % 4 = 3. Дальше идёт умножение и только после этого — сложение: 3 + 20 + 4 = 27. В результате в переменную d будет сохранено значение 27 и только после этого выполнится инкремент b. Получается, он никак не влияет на результат выражения.
Выберите порядковый номер у каждой операции для вычисления awesomeVariable.

int coolVariable = -1;
int perfectVariable = 7;
int awesomeVariable = (--coolVariable * 10) + (--perfectVariable + coolVariable); 
Сложение coolVariable и perfectVariable
5
Сложение во вторых скобках — четвёртая операция: 6+(?2)=4.
Умножение coolVariable на 10
3
Эта операция будет второй. Результат умножения ?20.
Префиксный декремент --coolVariable
1
Сначала выполняются операции в первых скобках, и первая из них — префиксный декремент. Значение coolVariable станет ?2.
Сложение результатов в скобках
4
Это последняя, пятая операция. После неё в переменную awesomeVariable будет записано значение ?16.
Префиксный декремент --perfectVariable
2
После того как вычислен результат первых скобок, программа переходит ко вторым. После вычитания единицы в perfectVariable сохранится значение 6.
Как вам задача?


Если в арифметическом выражении есть операции инкремента и декремента, они всегда меняют исходное значение переменной. Эти операции сами по себе являются законченными выражениями и для программы нет разницы, стоят они отдельно или внутри каких-либо вычислений:
Код

JAVA

1
public class Practicum {
2
    public static void main(String[] args) {
3
        int a = 5;
4
        --a; // программа вычтет единицу из a и сохранит в неё новое значение
5
        int b = --a * 10 + 24; // здесь у a также изменится значение на единицу
6
        System.out.println(a);
7
    }
8
}




Запустить код
В результате в переменную a будет сохранено значение 3. 
Операции с постфиксным инкрементом и декрементом выполняются только после того, как все другие завершены. Поэтому они не влияют на общий результат выражения, а меняют только значение своей переменной. 
Разберём, какие значения будут у каждой из переменных в результате выполнения такого кода:
Код

JAVA

1
public class Practicum {
2
    public static void main(String[] args) {
3
        int a = 10;
4
        int b = 22;
5
        int c = (--b / 2) - a++ * 2;
6
        System.out.println("a = " + a);
7
        System.out.println("b = " + b);
8
        System.out.println("c = " + c);
9
    }
10
}




Запустить код
Вычисления начинаются внутри скобок: Java отнимает единицу у исходного значения b, получает 21 и сохраняет это число обратно в b. Так значение b становится равно 21 и больше не меняется. 
21 делится на 2, получается 10.5, но так как производилось целочисленное деление, то остаток (0.5) отбрасывается — остаётся 10. Затем a умножается на 2, получается 20. От 10 отнимается 20. В переменную с сохраняется значение ?10.
Постфиксный инкремент a++ не влияет на значение с, так как выполняется после того, как её вычисления завершены. Меняется только исходное значение a. В итоге оно равно 11.

Не стоит пытаться всегда уместить сложные вычисления в одну строку: это может затруднить восприятие кода. Лучше с помощью других переменных разбить одно выражение на несколько. К тому же, по именам переменных будет проще догадаться, что именно происходит в коде. 
Например, разработчик приложения для заказа кофе составил следующий алгоритм для подсчёта цены:

double coffeeCupPrice = (cupSize * paperPrice + waterPrice + creamPrice + cupSize * beanPrice + syrupPrice) * crowdFactor; 
Согласно этому алгоритму происходит следующее:
Сначала вычисляется стоимость бумажного стаканчика под кофе — его размер cupSize умножается на цену картона paperPrice.
Затем вычисляется стоимость кофе — размер стакана cupSize умножается на стоимость зёрен beanPrice. Прибавляется стоимость воды waterPrice, молока или сливок creamPrice и сиропа syrupPrice.
Стоимость ёмкости и кофе суммируется.
Полученный результат умножается на повышающий коэффициент crowdFactor.
В коде эту логику лучше разбить на отдельные составляющие:

double cupPrice = cupSize * paperPrice;
double coffeePrice = waterPrice + creamPrice + cupSize * beanPrice + syrupPrice;
double coffeeCupPrice = (cupPrice + coffeePrice) * crowdFactor; 
Такой код гораздо легче воспринимать.
Практикум
Компьютер вычисляет одну операцию за раз. Поэтому для сложных выражений производится предварительный разбор на одиночные операции. Разбейте вычисление a = ++a - a % b++; на последовательные операции.
Первой операцией для вычисления станет…
Дмитрий
префиксный инкремент ++a
Практикум
Во вторую очередь необходимо посчитать…
Дмитрий
остаток от деления: значение a % b
Практикум
Третьим шагом компьютер…
Дмитрий
вычтет из ++a значение a % b
вычтет результат a % b из a
Практикум
В конце будет выполнено…
Дмитрий
вычисление инкремента b++
Практикум
Отлично! Вы понимаете порядок выполнения операторов инкремента и декремента в выражениях и теперь более уверенно можете их использовать в своих программах!
Как вам задача?


Начинающий фотограф Алиса решила накопить на новый объектив. Она открыла вклад в банке на три года под 4% годовых. В качестве стартового платежа Алиса внесла 5000 рублей и планирует каждый месяц пополнять счёт на 1000 рублей. 
Помогите Алисе вычислить, сколько денег будет на вкладе к концу срока и хватит ли ей на объектив с учётом того, что он стоит 41000 рублей. 
Вам нужно правильно расставить типы переменных и дополнить код необходимыми арифметическими операциями. Начисление процентов по вкладу это регулярная процедура, число повторений которой заранее известно — используйте для вычислений цикл for. Также учитывайте, что Алиса пополняет вклад после того, как начисляется доход от процентов. За обслуживание счёта каждый месяц банк списывает сумму равную 0.1% от первоначальной суммы.
Код

JAVA

1
public class Practicum {
2
    public static void main(String[] args) {
3
        double roubles = 5000; // сумма на счету
4
        double yearRate = 4; // годовая процентная ставка
5
        int numOfMonth = 36; // количество месяцев, на который открыт вклад
6
        double monthRefill = 1000; // ежемесячное пополнение
7
                double monthMaintenance = 0.001 * roubles; //плата за обслуживание счёта
8
                double monthRate = yearRate/12; // вычислите месячную процентную ставку
9
?
10
        for (int i = 1; i < numOfMonth; i++) { // дополните условие цикла
11
        double depositInterest = roubles * monthRate/100; // вычислите доход от процентов
12
        roubles += depositInterest; // добавьте доход от процентов
13
        roubles += monthRefill;// учтите ежемесячное пополнение
14
        }
15
?
16
        System.out.println("Через " + numOfMonth + " месяцев накопится " + roubles + " рублей");
17
        
18
        if (monthRefill >= 41000) { // определите, удалось ли достичь цели
19
            System.out.println("Ура! Можно идти в магазин за новым объективом!");
20
        } else {
21
            System.out.println("Нужно ещё немного подкопить.");
22
        }
23
    }
24
}
Через 36 месяцев накопится 43627.01391618608 рублей | Через 36 месяцев накопится 42675.669496308605 рублей
Ура! Можно идти в магазин за новым объективом! | Нужно ещё немного подкопить.

Что вы узнали
Вы прошли ещё одну тему. Надеемся, что она показалась вам понятной и простой. В любом случае вы узнали очень много нового:
Все арифметические операции можно производить как с целыми, так и с дробными числами.
Когда в арифметическом выражении есть дробное число, результат всегда будет дробным, так как значение типа double нельзя сохранить в переменной целого типа int.
Порядок выполнения арифметических операций в программировании основывается на математических правилах:
1. Сначала выполняются умножение и деление.
2. Затем — сложение и вычитание.
3. При наличии скобок действия в них выполняются первыми.
4. Считаем всегда слева направо.
Операция, увеличивающая переменную на единицу, называется инкрементом, а операция, уменьшающая переменную на единицу, — декрементом. Операторы ++ и -- называются операторами инкремента и декремента.

Введение в тему
Ура! Вам осталось пройти последнюю теорию в первом спринте. Как быстро пролетело время! Казалось, только вчера вы начали проходить наш вводный курс… Оставим сантименты! Расскажем, что вам предстоит узнать в новой теме. Вы изучите: 
как работает отрицание в логических выражениях;
узнаете, что такое логическое И (конъюнкция/умножение) и логическое ИЛИ (дизъюнкция/сложение);
приоритет операций: !, ==/!=, &&, ||;
для чего используется оператор switch;
в каких случаях лучше использовать switch вместо if-else.
Логические выражения. Утверждение и отрицание
С логическими переменными типа boolean также можно составлять выражения. Это часто необходимо при написании ветвлений — булевы выражения используются в условиях if-else. 
Утверждение
В переменную типа boolean чаще всего записывается некое утверждение. Оно может быть либо истинным — тогда переменная принимает значение true, либо ложным — значение переменной будет false. На основе утверждения можно составить логическую конструкцию — ветвление.
image
Например, если на улице идёт дождь, то вряд ли стоит идти гулять. В коде это можно отразить так:

if (weather.equals("Дождь")) { // если утверждение истинно,
    // ничего не делаем, сидим дома
} else { // если утверждение ложно
    System.out.println("Идём гулять!");
} 
Логическое выражение weather.equals("Дождь") — пример утверждения типа boolean. 
Отрицание
Чтобы изменить значение логического выражения на противоположное, нужно использовать отрицание. Оно обозначается оператором ! перед утверждением. Отрицание можно применить к любому логическому выражению. Например, при создании новой переменной:

boolean isPositive = x > 0; 
boolean zeroOrNegative = !(isPositive); 
Отрицание в условии ветвления предполагает, что требуется что-то сделать только в том случае, если утверждение ложно. Вернёмся к нашему примеру: если идёт дождь (утверждение) — не нужно ничего делать, а вот если нет дождя (отрицание) — идём гулять (действие). В таком случае можно упростить код через отрицание: 

if (!weather.equals("Дождь")) { // проверяем, что погода - НЕ дождь
    System.out.println("Идём гулять!");
} // блок else больше не нужен
    
 
Инвертировать можно в том числе и операции отношения. К примеру, возьмём ветвление, где в условии сравниваются числа:

if (temperature > 10) { 
} else {
    System.out.println("Окей, пора надевать пальто!");
} 
Надевать пальто следует, только если температура не выше 10 градусов — это можно записать в коде через отрицание. Чтобы его применить, нужно заключить всё выражение в скобки, а оператор ! поставить перед ними:

if (!(temperature > 10)) {
    System.out.println("Окей, пора надевать пальто!");
} 
Но не всегда стоит увлекаться отрицанием. Иногда достаточно поменять знак в выражении:

if (temperature <= 10) {
    System.out.println("Окей, пора надевать пальто!");
} 
Логические выражения temperature <= 10 и !(temperature > 10) равнозначны между собой, но первое воспринимать проще. Аналогично с отрицанием равенства: !(code == 9999) можно заменить на более удобную запись с оператором неравенства code != 9999.
Какой из вариантов противоположен по смыслу этому логическому выражению?

if (hamsterWeight < 100) {
    System.out.println("Надо срочно покормить хомяка!");
} else {
    System.out.println("Вес хомяка в норме, кормить не требуется.");
} 



if (hamsterWeight >= 100) {
    System.out.println("Вес хомяка в норме, кормить не требуется.");
} else {
    System.out.println("Надо срочно покормить хомяка!");
} 
Если изменить знак в выражении и поменять действия местами, смысл не поменяется.


if (NOT(hamsterWeight < 100)) {
    System.out.println("Вес хомяка в норме, кормить не требуется.");
} else {
    System.out.println("Надо срочно покормить хомяка!");
} 
В Java нет оператора NOT

Неправильный ответ

if (!(hamsterWeight < 100)) {
    System.out.println("Вес хомяка в норме, кормить не требуется.");
} else {
    System.out.println("Надо срочно покормить хомяка!");
} 
Чтобы инвертировать логическое выражение, достаточно было бы только отрицания, а тут изменено и само действие и смысл выражения сохранился.

Тоже правильный ответ

if (!(hamsterWeight < 100)) {
    System.out.println("Надо срочно покормить хомяка!");
} else {
    System.out.println("Вес хомяка в норме, кормить не требуется.");
} 
Знак поставлен точно так же, но смысл выражения инвертирован. Хомяка перекормят!
Как вам задача?


Супер! Теперь вы без проблем инвертируете любое утверждение, почти как Кристофер Нолан в своём фильме «Довод»! 
Умение мыслить логически — основа успеха в программировании! Прежде чем вы перейдёте к созданию сложных логических выражений, потренируйтесь создавать в коде ветвления с помощью утверждений и отрицаний.

Логические И и ИЛИ
В повседневной жизни редко встречаются ситуации, когда наши действия зависят только от одного условия. Например, можно пойти гулять несмотря на дождь, если на улице достаточно тепло и нет ветра, а у вас есть зонт и резиновые сапоги. 
Чтобы проверить несколько условий, в программировании используются логические операторы И и ИЛИ. Разберём подробно, как с их помощью строить в коде логические выражения.
Логическое И
Представьте, вы решили завести хомяка и пришли за ним в зоомагазин. У вас есть ряд требований: хомяк должен быть рыжего цвета, не старше двух месяцев, и должен весить больше 100 грамм. Выбирая питомца, вы проверяете эти условия по порядку:
image
Такая логическая последовательность приведёт только к двум результатам. Если выполнятся все условия — у вас появится хомяк, если не выполнится хотя бы одно — придётся поискать питомца в другом зоомагазине. Чтобы отразить это в коде, нужно одно за другим проверить каждое условие. Можно сделать это так:

if (hamsterColor.equals("Рыжий")) { 
    if (hamsterAge < 2) {
        if (hamsterWeight > 100) {
            System.out.println("Берём хомяка домой!");
        }
    }
}  
Или можно объединить эти выражения с помощью логического И. Эта операция обозначается в коде через &&. Выбор хомяка в коде будет выглядеть вот так:

if ((hamsterColor.equals("Рыжий")) && (hamsterAge < 2) && (hamsterWeight > 100)) { 
        System.out.println("Берём хомяка домой!");
} 
image
Если хотя бы одно из выражений-аргументов будет ложным — тогда и условие в ветвлении будет ложным. Если все операнды истинны, то условие тоже истинно. 
Часто с помощью && проверяют, входит ли число в диапазон. Например, чтобы убедиться, что пользователь ввёл пароль не меньше заданного количества символов:
Код

JAVA

1
public class Practicum {
2
    public static void main(String[] args) {
3
        int passwordSize = 7;
4
        System.out.println((passwordSize > 8) && (passwordSize < 10));
5
    }
6
}




Запустить код
Если изменить значение переменной passwordSize на 20, то программа напечатает false, так как условие выражения passwordSize < 10 будет ложным. Попробуйте подставить в passwordSize разные значения и посмотрите, как изменится результат. 
При объединении условий с помощью && каждое выражение лучше заключить в скобки. Так код проще читать и можно быть уверенным, что порядок выполнения операций не будет нарушен. Кроме того, не стоит строить длинное логическое выражение напрямую внутри ветвления. Удобнее предварительно сохранить его в переменную типа boolean:

boolean isHamsterAcceptable = (hamsterColor.equals("Рыжий")) && (hamsterAge < 2) && (hamsterWeight > 100);
if (isHamsterAcceptable) { 
        System.out.println("Берём хомяка домой!");
} 
Выберите выражения, где у переменной answer будет значение true.



int x = 0;
boolean answer = (x != 0) && (x > 5) && (x > 2); 
У всех операндов значение false, поэтому в answer никак не может сохраниться true.

Правильный ответ

int x = 0;
int y = 5;
boolean answer = (y > x) && (x <= 0) && ((x + y) < 14); 
Все три выражения истинны, а значит, и в переменную answer сохранится true.


int a = 15;
boolean answer = (a > 15) && (a >= 0) && (a < 100); 
Выражение a > 15 ложно, поэтому у переменной answer будет значение false.

Правильный ответ

int a = 11;
int b = a % 2;
boolean answer = (b != 0) && (a >= 0) && (a < 100); 
Все операнды имеют значение true, а значит, и у переменной answer будет такое значение.


boolean first = true;
boolean second = "Время".equals("Деньги");
boolean answer = first && second; 
Операнд second будет иметь значение false, а значит, в answer сохранится false.

Правильный ответ

boolean a = false;
int b = 10;
String c = "РазДва";
boolean answer = (!a) && (b <= 10) && (c.equals("Раз" + "Два")); 
Все операнды будут иметь значение true, значит, и в answer будет true.
Как вам задача?


Логическое ИЛИ
Допустим, вы твёрдо намерены завести хомяка и не хотите идти в другой магазин. Вы готовы взять питомца, который соответствует хотя бы одному из требований. Это значит, что хомяк должен быть или рыжим, или младше двух месяцев, или весить больше 100 грамм.
image
Если записывать все условия по порядку, то код будет выглядеть так:

if (humsterColor.equals("Рыжий")) { 
    System.out.println("Берём хомяка домой!");
} else {
    if (humsterAge < 2) {
    System.out.println("Берём хомяка домой!");
    } else {
        if (humsterWeight > 100) 
            System.out.println("Берём хомяка домой!");
        }
    }
} 
 
Удобнее объединить все выражения в одно с помощью логического ИЛИ. Эта операция возвращает true, если выполняется хотя бы один из операндов. Она обозначается в коде через || .
Выражение, записанное с помощью логического ИЛИ можно также сохранять в булеву переменную. А для записи его частей-операнд лучше использовать скобки. 
Например, значение переменной strangeLogic будет true, потому что одно из четырёх выражений, объединённых с помощью оператора ||, является истинным:

int a = 1; 
boolean strangeLogic = (a == 0) || (a == 1) || (a == 2) || (a == 3); // strangeLogic = true 
Переменная станет равна false, только если все его элементы будут ложными:

int a = 10; 
boolean strangeLogic = (a == 0) || (a == 1) || (a == 2) || (a == 3); // strangeLogic = false 
Условие для покупки хомяка с оператором || станет таким. 

boolean isHamsterAcceptable = (hamsterColor.equals("Рыжий")) || (hamsterAge < 2) || (hamsterWeight > 100);
if (isHamsterAcceptable) {
    System.out.println("Берём хомяка домой!");
} 
Операции логических И и ИЛИ иначе иногда называют логическими умножением и сложением. И вот почему. Если принять, что значение true — это 1, а значение false — это 0, то общий результат вычислить достаточно легко. Умножение на ноль всегда даст ноль, а если хотя бы одно из слагаемых равно единице, то сумма уже не может быть нулевой.
image
Выберите варианты, которые возвращают false.



int a = 15;
boolean answer = (a > 15) || (a >= 0) || (a < 100); 
Использован оператор ||, а выражения (a >= 0) и (a < 100) истинны, значит, в переменную answer сохранится true.

Правильный ответ

int a = 15;
boolean answer = (a > 15) && (a >= 0) && (a < 100); 
Использован оператор &&, а выражение (a > 15) ложное, значит, в переменную answer сохранится false.


int x = 10 * 10 * 10;
x++;
boolean isBig = x > 1000;
boolean isNegative = x < 0;
boolean answer = (isBig) || (isNegative); 
В переменную x сохранится 1001, в isBig сохранится true, значит, в переменную answer сохранится true.

Правильный ответ

int a = 15;
int b = a / 10;
boolean answer = (b == 0) && (a == 0); 
В b сохранится 1. Все «скобки» — ложные, значит, в переменную answer сохранится false

Правильный ответ

int a = 15;
int b = a;
int c = b;
boolean answer = (c != 15) || (b != 15); 
В b и c сохранится 15. Значения в скобках ложные, значит, в переменную answer сохранится false.


boolean falseVariable = !(!(true));
int a = 10;
int b = a--;
boolean answer = falseVariable || (b == 10); 
Двойное отрицание над true вернёт true. В переменную b сохранится 10. Оба операнда будут равны true, значит, в переменную answer также сохранится true.
Как вам задача?


Поздравляем! Теперь вы знакомы с тремя китами булевой логики: отрицанием, логическим И и логическим ИЛИ.
image
Порядок логических операций
При написании логического выражения разные операции можно комбинировать друг с другом. При этом важно учитывать порядок их выполнения. 
Допустим, что поиски домашнего питомца оказались успешными — в зоомагазине всё-таки нашлись трое подходящих хомяков:
Байт. Рыжий короткошёрстный хомяк, ему три месяца, и он упитанный — весит больше 100 грамм.
Ниндзя. Рыжий хомяк с белым носом и брюхом, младше двух месяцев, щекастый (больше 100 грамм) и пушистый.
Паскаль. Рыжий в чёрную крапинку, тоже младше двух месяцев. Маленький (чуть меньше 100 грамм) и короткошёрстный.

Условие выбора питомца требуется усложнить. Нужно, чтобы хомяк был рыжим или рыже-белым, но не в чёрную крапинку, строго младше двух месяцев, а также либо пушистым, либо упитанным. Чтобы проверить эти пункты, требуется объединить в одно выражение все три операции — логические И и ИЛИ, и отрицание.

// логическое И
hamsterColor.equals("Рыжий") && (hamsterAge < 2); 
// отрицание
!hamsterPattern.equals("В крапинку");
// логическое ИЛИ
hamsterWeight > 100 || hamsterIsFluffy == true  
При комбинировании разных логических операций в одном выражении или условии нужно учитывать приоритет их выполнения в коде:
Сначала всегда выполняется отрицание !.
Логическое умножение предшествует сложению — поэтому логическое И && в приоритете.
Логическое ИЛИ || при наличии других операций выполняется последним.
Логические операции так же, как и арифметические, выполняются слева направо. Операции в скобках вычисляются в первую очередь — поэтому скобки помогут добиться нужного порядка действий в выражении. 
Исходя из этих правил, составим логическое выражение для определения подходящего цвета хомяка: 

                                                       2                                     3   1
boolean isColoredRight = (hamsterColor.equals("Рыжий") || hamsterColor.equals("Рыже-белый")) && !hamsterPattern.equals("В крапинку"); 
Хомяк должен быть рыжий или рыже-белый и не должен быть в крапинку. Сначала выполнится отрицание — 1, потом ИЛИ в скобках — 2, и потом И — 3. Выражение с отрицанием !hamsterPattern.equals("В крапинку") необязательно брать в скобки — оно и так выполнится первым. А вот если не поставить скобки для || , то первым выполнится && — результат выражения получится неверным.

Аналогично составим выражение для проверки подходящего возраста и веса хомяка или пушистости:

                                               2                        1 - из-за скобок
boolean isAgeAndWeightRight = (hamsterAge < 2) && (hamsterWeight > 100 || hamsterIsFluffy == true); 
Переменные по определению параметров можно использовать в условии ветвления:

if (isColorRight && isAgeAndWeightRight) {
    System.out.println("Берём хомяка!");
} 
По этим условиям победил хомяк Ниндзя.
Расставьте операции в логическом выражении isLogic по порядку вычисления:

int x;
int y;
boolean isTrue;
...
                  a        b         c               d
boolean isLogic = !(x > y) || isTrue && (x % y == 0) || isTrue; 
1
a
Отрицание всегда первое
2
c
Приоритет И выше, чем приоритет ИЛИ
3
b
Приоритет ИЛИ ниже, чем приоритет И
4
d
Операция ИЛИ слева приоритетнее операции ИЛИ справа
Как вам задача?


Отлично, теперь вы легко распутаете запутанные выражения со скобками и хитрой последовательностью вычислений.
Логические вычисления по короткой схеме
Во всех уроках этой темы мы приводили в пример операторы && и ||. Рассмотрим пример условий выбора хомяков. Этот вариант записи вам уже знаком:

(hamsterAge < 2) && hamsterColor.equals("Рыжий") 
Предлагаем вам думать не только о результате вычисления выражения, но и о процессе его вычисления. 
Дело в том, что Java вычисляет значения слева направо по порядку. В случае с логическими операциями && и || используется логическое упрощение, так называемая “короткая схема”. 
Для выражения слева && справа оно звучит так: если значение слева ложь, то всё выражение ложь, а если слева истина, то нужно проверить значение справа. В первом примере Java даже не попытается проверить цвет хомячка, если его возраст больше или равен двум месяцам. Для выражения слева || справа действует похожее правило упрощения: если слева истина, значит всё выражение истина, а если слева ложь, то нужно проверять значение справа.  
?? Если принять, что 0 означает ложное выражение, а 1 — истинное, и применить эти правила к двоичной арифметике, можно сформулировать следующие утверждения:
Если что угодно умножить на ноль, получим ноль.
0?1=0
0?0=0
Если что угодно сложить с единицей, получим единицу.
0+1=1
1+1=1
Представьте, что вы читаете книгу с двумя критериями: первая глава должна быть интересной (&&), или хотя бы одна из первых двух глав должна быть интересной (||).
Для &&: Если первая глава скучная, вы не станете проверять вторую, так как книга уже «не прошла».
Для ||: Если первая глава интересная, вы сразу берёте книгу, не проверяя вторую.
Java использует тот же подход: проверяет ровно столько, сколько нужно для определения результата, что делает выполнение кода быстрее и эффективнее.
Однако, в языке Java существуют операторы & и |, которые можно назвать “длинное” И и “длинное” ИЛИ. Эти операторы можно применять со значениями типа boolean. И может показаться странным, что существует два разных оператора для одной и той же цели. Вот вариант с длинным И:

(hamsterAge < 2) & hamsterColor.equals("Рыжий") 
В случае с длинным И программа будет намеренно считать оба значения слева и справа, не используя логические упрощения. В наших примерах вычисления довольно простые, но в случае с длинными цепочками формул оптимизация может быть значительной. 
Разработчики используют это свойство длинных и коротких вычислений не только в целях оптимизации, но и для того чтобы более чётко управлять вычислениями. Например, свойство короткого И используется, чтобы избежать лишней проверки в следующем примере.

String maybeColor = scanner.nextLine(); //представим, что хитрый пользователь ничего не ввёл.
//maybeColor == "" (истина!)
if(maybeColor != "" && maybeColor.equals(hamsterColor)){
    ...
} 
В этом примере показано, как проверочное логическое выражение maybeColor != "" предотвращает лишние вычисления при проверке основного логического выражения maybeColor.equals(hamsterColor). Аналогичный пример защиты от ошибки деления на 0 приведён ниже.

num1 = 5;
num2 = scanner.nextInt(); //пользователь может ввести 0;

if(num2 != 0 && num1 % num2 == 0){
    System.out.println("Числа делятся нацело");
} 
Вторая проверка не будет выполнена, если первая проверка ложная. В подавляющем большинстве случаев разработчики используют логические вычисления по короткой схеме.

Оператор switch
Во многих задачах результат выполнения программы зависит от выбора одного из нескольких вариантов. 
Перед вами код кофемашины, которая умеет готовить капучино, американо и эспрессо. Набор действий, которые должна выполнить кофемашина, зависит от одного единственного параметра — названия напитка:
Код

JAVA

1
public class Practicum {
2
?
3
    public static void main(String[] args) {
4
        String coffeeType = "Капучино";
5
        if (coffeeType.equals("Капучино")) {
6
            System.out.println("Приготовлено эспрессо.");
7
            System.out.println("Добавлено молоко.");
8
        } else if (coffeeType.equals("Американо")) {
9
            System.out.println("Приготовлено эспрессо.");
10
            System.out.println("Добавлена вода.");
11
        } else if (coffeeType.equals("Эспрессо")) {
12
            System.out.println("Приготовлено эспрессо.");
13
        } else {
14
            System.out.println("Такой тип кофе я не готовлю!");
15
        }
16
    }
17
}




Запустить код
В нашем примере выбор реализован через цепочку if-else для каждого варианта. Это выглядит довольно громоздко.

Специально для таких случаев был придуман оператор switch (англ. «?переключатель»). С помощью него можно заменить несколько if-ов лаконичной конструкцией, которая реализовывает выбор одного из нескольких вариантов.
В реальной жизни есть много примеров механизмов, которые по принципу действия похожи на switch. Например, переключатель света фар у машины. Меняя положение переключателя, мы выбираем определённый режим работы: габаритные огни, ближний свет, дальний свет и так далее.

Код

JAVA

1
public class Practicum {
2
?
3
    public static void main(String[] args) {
4
        String coffeeType = "Капучино";
5
        switch (coffeeType) {
6
            case "Капучино":
7
                System.out.println("Приготовлено эспрессо.");
8
                System.out.println("Добавлено молоко.");
9
                break;
10
            case "Американо":
11
                System.out.println("Приготовлено эспрессо.");
12
                System.out.println("Добавлена вода.");
13
                break;
14
            case "Эспрессо":
15
                System.out.println("Приготовлено эспрессо.");
16
                break;
17
            default:
18
                System.out.println("Такой тип кофе я не готовлю!");
19
        }
20
    }
21
}




Запустить код
Приведённый выше код выполняет то же самое, что и аналогичный — с конструкциями if-else, но так он выглядит аккуратнее.
Теперь рассмотрим структуру оператора switch. Она выглядит следующим образом:

switch (выражение) {
    case значение1:
        // сделать что-то для значения 1
        break;
    case значение2:
        // сделать что-то для значения 2
        break;
    ...
    case значениеN:
        // сделать что-то для значения N
        break;
    default :
        // если не подошёл ни один из вариантов, то выполнить код отсюда
} 
А вот алгоритм выполнения такого кода:
Сначала вычисляется значение выражения, указанного в скобках после ключевого слова switch. Оно может быть типа int , String или некоторых других. Тип значений в строках с ключевым словом case и выражения в скобках должны совпадать.
Если значение выражения совпало с одним из case значений, то выполнится код соответствующего блока до слова break и на этом switch-конструкция завершится.
Если значение выражения не совпадает ни с одним из case-значений, то выполнится блок кода для default.
Блок default — необязательный, можно написать оператор switch и без него. В таком случае если значение выражения не совпадает ни с одним из case-вариантов, то ничего не произойдёт. Но рекомендуется всё же добавлять блок default, даже если он не содержит кода. Так вы сможете отловить все непредвиденные значения и продемонстрировать другим программистам, что в вашей switch-конструкции предусмотрены все возможные варианты. 
Ключевое слово break тоже необязательно. Если его нет, то код продолжит выполнение следующих case-блоков до первого встреченного break или до конца оператора switch. Такое иногда встречается, если для двух и более вариантов нужна одинаковая обработка.
Несколько вариантов case-блоков, использующих один код, можно группировать. Например, вот код для определения количества дней в месяце. Запустите код, а затем добавьте break в одно из выражений case и проверьте, изменится ли результат:
Код

JAVA

1
public class Practicum {
2
?
3
    public static void main(String[] args) {
4
        int month = 5;
5
?
6
        switch (month) {
7
            case 1: // январь
8
            case 3: break;// март
9
            case 5: // май
10
            case 7: // июль
11
            case 8: // август
12
            case 10: // октябрь
13
            case 12: // декабрь
14
                System.out.println("В этом месяце 31 день.");
15
                break;
16
            case 2: // февраль
17
                System.out.println("В этом месяце 28 или 29 дней.");
18
                break;
19
            case 4: // апрель
20
            case 6: // июнь
21
            case 9: // сентябрь
22
            case 11: // ноябрь
23
                System.out.println("В этом месяце 30 дней.");
24
                break;
25
            default:
26
                System.out.println("Месяца с таким номером не существует.");
27
        }
28
    }
29
}




Запустить код
Благодаря группировке вариантов в switch-конструкции, улучшается читаемость кода и устраняется дублирование.
Выберите правильные утверждения про switch:


Правильный ответ
switch — это альтернатива if-else со сравнениями по одной переменной.
Если if-else состоит из нескольких вариантов перечисления, то его можно легко переписать в switch и повысить читаемость кода.

Блок default — обязательный.
Необязательно указывать блок default, но мы рекомендуем обрабатывать ситуацию, когда значение не найдено.

Правильный ответ
Значение выражения switch может быть типа String или одним из примитивных типов, например int.
В следующих уроках вы узнаете про ещё один тип, который можно использовать в выражении switch.

Ключевое слово break обязательно для каждой опции.
Иногда для двух опций нужно выполнить один и тот же код и в этом случае break можно не писать.

Правильный ответ
В блоке default break не нужен.
default ставится в конце оператора, поэтому прерывать его выполнение нет смысла.
Как вам задача?


В некоторых случаях вы можете встретить конструкцию switch, где в каждом варианте case использован оператор return. В данном случае break также не пишется, так как исполнение switch прервётся при выходе.

String command = scanner.nextLine();
switch (command){
    case "делай раз":
        System.out.println("Первое действие выполнено!");
        return "раз";
    case "делай два":
        System.out.println("Второе действие выполнено!");
        return "два";
    case "закончить":
        System.out.println("Закончил упражнение!");
        return "всё";
    case "делай три":
        System.out.println("Третье действие выполнено!");
        return "три";
    ...   
} 
Соотнесите блоки кода с результатом.
A)

        String i = "right";

        switch (i) {
            case "left":
                System.out.print("Налево. ");
            case "right":
                System.out.print("Направо. ");
            case "straight":
                System.out.print("Прямо. ");
            default:
                System.out.print("Такое значение не предусмотрено.");
        } 
Б)

        String i = "right";

        switch (i) {
            case "left":
                System.out.print("Налево. ");
                break;
            case "right":
                System.out.print("Направо. ");
                break;
            case "straight":
                System.out.print("Прямо. ");
                break;
            default:
                System.out.print("Такое значение не предусмотрено.");
        } 
В)

        String i = "right";

        switch (i) {
            case "left":
                System.out.print("Налево. ");
                break;
            case "right":
                System.out.print("Направо. ");
            case "straight":
                System.out.print("Прямо. ");
                break;
            default:
                System.out.print("Такое значение не предусмотрено.");
        } 
Г)

        String i = "right";

        switch (i) {
            case "left":
                System.out.print("Налево. ");
                break;
            case "right":
            case "straight":
                System.out.print("Прямо. ");
                break;
            default:
                System.out.print("Такое значение не предусмотрено.");
        } 
Направо. Прямо.
А
В условии для "right" нет break, поэтому оператор выполнит этот блок и следующий до break.
Направо.
А
В выражении для "right" есть break, поэтому оператор выполнит только один блок.
Направо. Прямо. Такое значение не предусмотрено.
А
В этом коде отсутствует break;, поэтому обработаются все блоки с выражениями, начиная с "right".
Прямо.
А
В этом коде два выражения используют один и тот же блок обработки. 
Как вам задача?


Исправьте код так, чтобы он выводил Java — это язык для всего.
Код

JAVA

1
public class Practicum {
2
?
3
    public static void main(String[] args) {
4
        String language = "Java";
5
?
6
        switch (language) {
7
            case "Java":
8
            System.out.println("Java — это язык для всего.");
9
break;
10
            case "Python":
11
                System.out.println("На Python часто обрабатывают данные и разрабатывают нейронные сети.");
12
            case "JavaScript":
13
                System.out.println("JavaScript - отличный выбор для веб-разработки");
14
            default:
15
                System.out.println("Про язык программирования " + language + " мы ничего не знаем.");
16
        }
17
?
18
    }
19
}
Отсутствующий break — это одна из самых частых ошибок при написании конструкции switch. Не забывайте расставлять их там, где нужно.


Подсказка





Проверить
switch — без сомнений полезный оператор, который повышает читаемость кода. Главное не забывать правильно расставлять break. Но если логика чуть сложнее, чем выбор по значению одной переменной, то есть риск вместо краткого лаконичного решения получить неуправляемого монстра. Всё зависит от конкретной задачи.
Что вы узнали
Вы закончили изучать теорию первого спринта. В следующей, заключительной теме вас ждут уроки, изучив которые вы установите на свой компьютер среду разработки и приступите к выполнению финального проекта. А пока вспомним, что вы изучили:
Чтобы изменить значение логического выражения на противоположное, нужно использовать отрицание: оно обозначается оператором ! перед утверждением.
Чтобы проверить несколько условий, в программировании используются логические операторы И и ИЛИ: && и ||.
При комбинировании разных логических операций в одном выражении или условии нужно учитывать приоритет их выполнения в коде: сначала всегда выполняется отрицание !; логическое умножение предшествует сложению, поэтому логическое И && в приоритете; логическое ИЛИ || при наличии других операций выполняется последним.
switch — это альтернатива if-else со сравнениями по одной переменной.

Введение в тему
Вы уже умеете писать программы в тренажёре Практикума. Но пришло время покорить новую вершину — научиться создавать программы на своём компьютере! В этой теме вы настроите свою собственную среду разработки. А если детальнее, то в следующих двух уроках вы:
Узнаете, зачем нужна среда разработки и почему лучше писать программы в ней, а не в блокноте.
Познакомитесь с самой популярной средой разработки на Java — IntelliJ IDEA — и установите её на свой компьютер.
Разберётесь, что такое JDK и почему без него запустить программу не получится.
Напишете и запустите первую программу у себя на компьютере.
Знакомство с IntelliJ IDEA
В предыдущих уроках вы писали код на Java и создавали свои первые программы в тренажёре Практикума. Однако, чтобы программировать на своём компьютере, вам понадобятся специальные приложения.
Программы можно писать в любом текстовом редакторе: например, в блокноте. Однако это очень неудобно. Там нет ни подсветки синтаксиса, ни автодополнения. Для того чтобы программисты могли сосредоточиться на создании качественного кода и не отвлекаться при этом на технические неудобства, были придуманы интегрированные среды разработки.
Интегрированная среда разработки (англ. Integrated Development Environment, или IDE) — это программа, в которой собран комплекс инструментов, необходимых для быстрой и эффективной работы над проектом. Наиболее популярная IDE среди разработчиков на Java — IntelliJ IDEA. Вот её основные компоненты: 
редактор кода с функцией автодополнения, удобной подсветкой синтаксиса, навигацией и встроенными подсказками;
набор инструментов для проверки Java-кода, подготовки к выполнению и непосредственного выполнения программ на Java;
отладчик — специальный инструмент для поиска ошибок и отслеживания значений переменных в процессе исполнения кода;
анализатор кода, который проверяет код всего проекта и ищет дубликаты, неиспользуемый, избыточный код и другие проблемы, а также предлагает варианты исправления.
Конечно, в IntelliJ IDEA есть и другие полезные средства. Вы познакомитесь с ними в течение курса. Но сначала вам нужно установить IntelliJ IDEA на свой компьютер.
Выберите верные утверждение о среде разработки:


Среда разработки — это программа для установки программ на компьютер.
Программа для установки программ нужна всем пользователям, а среда разработки создавалась для удобства программистов.

Правильный ответ
Среда разработки — это программа, в которой содержится всё необходимое для разработки приложений.
Всё необходимое и даже больше. Можно очень долго изучать все полезные инструменты, которые есть в IntelliJ IDEA.

Правильный ответ
С помощью среды разработки можно запускать Java-программы
Так и есть — это простой и удобный способ запустить программу.

Правильный ответ
Среда разработки содержит в себе специальный инструмент, который помогает искать ошибки в программах.
Такой инструмент называется отладчик.

Неправильный ответ
Одна из функций среды разработки — ускорение работы Java-программ.
Среда разработки помогает писать код, но не ускоряет его.

Неправильный ответ
Инструмент в среде разработки, который позволяет искать дубликаты кода, называется редактор кода.
Дубликаты ищет анализатор кода, а редактор делает работу с кодом более удобной.
Как вам задача?


Установка IntelliJ IDEA
Выберите свой тип операционной системы и выполните пункты, описанные в инструкции.
Windows
Загрузите файл по ссылке и запустите его. 
На шаге Installation Options (англ. «Параметры установки») есть следующие настройки:

Create Desktop Shortcut (англ. «Создать ярлык на рабочем столе»). Выберите при необходимости «Создать ярлык на рабочем столе».
Update context menu (англ. «Обновить контекстное меню»). Если отметить этот пункт, то при нажатии правой кнопкой мыши на любую папку в выпадающем меню появится «Открыть папку как проект». Отмечать этот пункт необязательно: он может понадобиться для быстрого запуска содержимого папки в IDEA. Внутри самой IDEA есть меню для открытия проекта.
Create Associations (англ. «Создавать ассоциации»). Здесь вы можете выбрать расширения файлов, которые по умолчанию будут открываться в IDEA по двойному щелчку левой кнопкой мыши. Выберите все пункты.
Update PATH variable (англ. «Обновить переменную PATH»). Этот пункт отвечает за добавление в командную строку возможности запускать IntelliJ IDEA из любого каталога. Если вы привыкли запускать приложения нажатием на иконку, то вам необязательно выбирать этот пункт. Если же вы хотите лучше освоить работу с терминалом, смело отмечайте Add “bin” folder to the PATH.
Отлично! Остальные пункты можно пропустить: нажимайте на кнопку Next (англ. «Дальше») до тех пор, пока процесс установки не завершится.
Mac OS
Загрузите программу установки в зависимости от вашего процессора: Intel или Apple Silicon. Откройте .dmg-файл и перетащите IntelliJ IDEA в папку «Программы» (Applications).
Linux
Введите в терминале команду установки:

sudo snap install intellij-idea-community --classic 
Теперь на вашем компьютере есть IntelliJ IDEA. Чтобы её запустить, воспользуйтесь следующей командой: 

intellij-idea-community 
Создание проекта
Когда вы запустите IntelliJ IDEA в первый раз, программа предложит вам сделать несколько настроек.
Так выглядит стартовое окно:

Нажмите на New Project (англ. «Новый проект»). Введите название проекта: programmers-day. Название проекта может быть любым — в зависимости от темы и назначения. Имя programmers-day понадобится для задания, которое ждёт вас в следующем уроке.

Поле Location (англ. «Расположение») означает директорию, куда будет сохранён ваш новый проект. Его можно оставить по умолчанию. Если поставить галочку в поле Add sample code (англ. «Добавить пример кода»), IntelliJ IDEA автоматически сгенерирует стартовый код для вашего проекта. Но в нашем случае этого не требуется. 
В поле Build system выберите значение IntelliJ — чтобы проект не создавался под какую-то конкретную систему сборки. С системами сборки проектов мы будем знакомиться позже в нашем курсе.
Поле JDK пока оставьте пустым. В следующем уроке вы узнаете, что такое JDK и для чего он нужен в проекте, там же мы продолжим настройку проекта и заполним это поле. Пока же можно просто нажать кнопку Create (англ. «Создать»). Вы можете увидеть предупреждение, что SDK не выбран. Чтобы продолжить работу без SDK, нажмите Yes (англ. «Да»). Проект создан!
Обзор интерфейса IntelliJ IDEA
Основное окно программы состоит из трёх частей: 
панель навигации,
панели инструментов (окна для просмотра файлов проекта, его структуры, запуска и прочие),
окно редактора.

Панель навигации находится в верхней части окна. В ней есть два компонента: 
1) меню с настройками и полезными действиями (открытие/закрытие проекта, анализ кода, генерация документации и прочее);
2) кнопки для самых частых действий. 
По умолчанию здесь есть несколько основных кнопок, но вы можете настроить эту панель самостоятельно. Пока что вам понадобятся следующие элементы:
кнопка Run (англ. «Запустить») в виде зелёного треугольника предназначена для запуска проекта.
выпадающий список Select Run/Debug configuration (англ. «Выберите конфигурацию Запустить/Отладить»). Здесь можно сохранять и редактировать разные настройки для запуска.
кнопка Stop (англ. «Стоп») нужна для принудительной остановки программ. Если программа не запущена, то кнопка выглядит как серый квадрат, а если программа выполняется — квадрат становится красным.
Панель инструментов находится по краям окна программы. Самая полезная для нас на данный момент часть панели инструментов — вкладка Project (англ. «Проект»). В этой вкладке отображается структура проекта. Здесь можно, например, открывать, добавлять и удалять файлы. 
В окне редактора происходит основная работа программиста:  именно там можно писать и редактировать код.
?? Для быстрого доступа к отдельным командам в  IntelliJ IDEA часто используют горячие клавиши (англ. hotkey). Посмотреть все комбинации клавиш и настроить свои можно в специальном меню. Откройте File > Settings... > Keymap или нажмите клавиши Ctrl+Alt+S и выберите в левом меню раздел Keymap.
Структура проекта
Теперь подробнее посмотрим на проект, который вы только что создали. Для этого нужно открыть вкладку Project.

В структуре вашего проекта автоматически появились две папки: .idea и src. 
Все Java-файлы, относящиеся к проекту, должны храниться в папке src (от англ. source — «исходники»). Если для работы проекта требуются дополнительные ресурсы (например, изображения, файлы настроек и т.д.), для них рекомендуется создать папку на одном уровне с src и назвать ее resources (от англ. resource — «ресурсы»).
А папку .idea IntelliJ IDEA генерирует для себя, чтобы хранить в ней информацию, которая нужна для её корректной работы. 
Чтобы добавить новый файл с кодом, вам нужно создать новый Java-класс — поскольку весь код на Java размещается внутри классов. Откройте контекстное меню для папки srcи выберите New > Java Class, в новом окне введите имя класса — Practicum и нажмите Enter. Поздравляем — вы создали пустой класс с именем Practicum! В следующем уроке вы добавите в этот класс код и научитесь его запускать.
Выберите верные утверждения относительно структуры проекта в IntelliJ IDEA:


Чтобы написать код, нужно самостоятельно создать в корне проекта папку code.
Такой необходимости нет. IntelliJ IDEA автоматически создаёт папку src, в которой и размещается код.

Если в проекте нужно использовать изображение, его необходимо поместить в папку images в корне проекта.
Конкретного требования к названию такой папки нет. Пользователь может создать в корне проекта папку с произвольным именем и использовать её для хранения изображений. Однако рекомендуется, чтобы имя папки соответствовало ее содержимому.

Тоже правильный ответ
Чтобы написать код, нужно создать новый класс в папке src — этот класс автоматически откроется в окне редактора.
Так и есть - в этом классе мы и будем в дальнейшем писать программу

Правильный ответ
Не рекомендуется изменять содержимое папки .idea вручную.
Эта папка используется IntelliJ IDEA для своих внутренних целей, поэтому её содержимое лучше не трогать.

Как запустить первую программу
Чтобы компьютер мог «читать» и корректно выполнять код на Java, ему нужна специальная программа. А точнее целый набор программ, который называется Java Development Kit (англ. «Комплект для разработки на Java»), или сокращённо — JDK. Именно JDK позволит вам запустить проект, который вы создали в предыдущем уроке в IntelliJ IDEA.
Главной частью JDK является компилятор — специальная программа, которая переводит код на языке Java, удобный для человека, в машинные команды, которые может исполнять компьютер. Ещё в JDK есть стандартная библиотека Java. Это набор классов с готовыми решениями частых задач: реализация разных структур данных, стандартных алгоритмов и т. д., которые помогут вам в разработке собственных программ. Например, уже знакомые вам классы String и Scanner являются частью JDK. Кроме того, частью JDK является генератор документации из комментариев к коду и другие полезные инструменты.
Выбор JDK
Язык Java был создан в 1995 году и с тех пор сильно изменился: все эти годы он развивался и совершенствовался усилиями сообщества программистов. Когда несколько доработок языка готовы к использованию, его текущая версия фиксируется и выпускается новый JDK. 
Сейчас наиболее популярны версии старше 8-й. В этом курсе мы будем работать с 21-й — это версия, у которой есть долговременная поддержка. 
?? Если код, написанный на одной из последних версий языка, попробовать выполнить на компьютере с более ранней JDK, то он не запустится — компьютер его не сможет «понять». 
Совсем как в обычном языке. Современный человек, прочитав текст на старославянском, скорее всего, сможет в общих чертах представить, о чём он. А вот если бы перед глазами средневекового монаха вдруг оказался пост из Фейсбука о беспилотной доставке умных станций для дома со встроенными голосовыми помощниками... Вряд ли бы он понял, о чём идёт речь.
Права на язык Java принадлежат американской корпорации Oracle (англ. «Оракул»). Именно она собирает от пользователей языка предложения по изменениям и решает, какие из них должны быть в новой версии. 
При этом она не запрещает другим компаниям создавать свои JDK. Они могут отличаться условиями для коммерческого использования, скоростью выполнения кода и процессом установки. При этом результат работы программ, созданных с помощью разных JDK, будет одинаковый.
Вот самые распространенные JDK:
OpenJDK. Если вы хотите познакомиться с новейшим функционалом Java, то можете выбрать этот JDK. Он полностью бесплатный, но доступна только самая последняя версия без поддержки.
Oracle. Это JDK от главного поставщика Java. Её можно использовать бесплатно, если программист занимается некоммерческой разработкой, а за использование в рабочей среде нужно платить компании Oracle.
Amazon Coretto. Бесплатная реализация JDK от Amazon с долгосрочной поддержкой.
Выберите, для чего нужен JDK:


Неправильный ответ
Для редактирования кода программ на Java.
В JDK есть много полезных инструментов, но ничего для написания или редактирования кода не предусмотрено — для этого стоит использовать среду разработки.

Тоже правильный ответ
Для запуска и выполнения программ на Java.
Это его главные функции. А остальные инструменты помогают писать код.

Для хранения информации, которую могут использовать запускаемые программы.
Это назначение переменных окружения.

Для отслеживания изменений и сохранения разных версий кода по мере написания программы.
Для этого есть специальные инструменты, со временем вы о них узнаете!
Как вам задача?


Установка JDK
Чтобы запустить код на Java на своём компьютере, вам нужно установить JDK. Самый простой способ сделать это — воспользоваться помощью IntelliJ IDEA. Она сама скачает JDK и установит его на ваш компьютер, а также настроит использование JDK в проекте. Ещё есть вариант установки JDK отдельно от IntelliJ IDEA, с ним вы познакомитесь чуть позже. 
Чтобы установить JDK, нажмите на Setup SDK (англ. «Установить SDK») в верхней части окна редактора и выберите действие Download JDK (англ. «Загрузить JDK»):

Аналогичную команду можно выполнить через пункт меню File > Project Structure:


Мы будем использовать Amazon Coretto JDK.  Выберите ее в параметрах загрузки:

Дождитесь, когда IntelliJ IDEA загрузит JDK, это может занять несколько минут. После этого надпись с предложением добавить JDK исчезнет. Это значит, что JDK корректно установлена и настроена, и можно использовать её для запуска Java-программ.
Запуск программы
Поздравляем! Теперь вы можете запускать программы на своём компьютере. Откройте класс Practicum, который вы создали в предыдущем уроке, и добавьте в него метод main:

import java.util.Scanner;

public class Practicum {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("Введите свое имя:");
        String name = scanner.nextLine();
        System.out.println("Привет, " + name + "!");
    }
} 
Чтобы запустить метод, нажмите на зелёную стрелку слева от названия метода и выберите действие Run ‘Practicum.main()’ (англ. «Запустить ‘Practicum.main()’»).

В нижней части экрана появится панель Run (англ. «Запуск»), в которой будет отображаться вывод вашей программы. Там же вы можете вводить данные, если программа требует этого:

Если во время работы программы произойдёт ошибка, информация о ней отобразится в той же панели.
Чтобы запустить программу повторно, можно воспользоваться кнопкой Run, расположенной на панели навигации, с помощью неё можно повторить запуск последней запущенной программы.
Программа на данный момент выводит на экран строку с приветствием и завершает свою работу. Некоторые программы, однако, могут работать достаточно долго, и бывает необходимо завершить их работу принудительно. Например, если вы поняли, что в программе есть ошибка. Чтобы остановить запущенную программу, воспользуйтесь кнопкой Stop (англ. «Остановить») на панели навигации.
Вы можете заметить, что после запуска программы во вкладке проекта добавилась ещё одна папка с названием out. В этой папке IntelliJ IDEA будет размещать версии ваших классов, преобразованные специальным образом для запуска. Папку out IntelliJ IDEA создаёт автоматически, изменять её содержимое вручную не нужно.
Выберите верные утверждения про работу с проектом в IntelliJ IDEA:


Правильный ответ
Чтобы запустить программу в IntelliJ IDEA, нужен установленный JDK.
Без JDK запустить программу не получится, хотя писать код можно и без него.

В IntelliJ IDEA можно использовать только официальный JDK от Oracle.
Такого ограничения нет. При установке JDK можно выбрать любую из распространённых версий.

Перед тем как запустить программу, необходимо скопировать написанные классы в папку out.
IntelliJ IDEA самостоятельно управляет содержимым папки out — достаточно просто запустить код.

Правильный ответ
Чтобы запустить программу, нужно вызвать команду Run у метода main.
Программы на Java запускаются вызовом метода main.

Все программы, запущенные в IntelliJ IDEA, должны самостоятельно прекращать работу через короткое время.
Это не обязательно. Работу программы можно в любой момент остановить командой Stop.

Работа в IDEA
В этом уроке вы подробнее познакомитесь с функционалом IDEA. В видео наставник курса покажет, как запускать и создавать проект, обрабатывать разные виды ошибок и запускать код проекта.
Для каждого видео подготовлены проекты, на которых вы можете попрактиковать подходы, изученные в видео. Рекомендуем не пропускать этот шаг, чтобы в дальнейшем эти действия не вызывали у вас сложностей.
Важно: если IDEA у вас еще не установлена, сделайте это перед просмотром видео.
Начало работы с готовым проектом
Откройте проект и запустите его в IDEA. Изучите его содержимое.
Выберите все сущности, которые отображаются в дереве проекта


Правильный ответ
src
Директория отображается в дереве проекта.

Тоже правильный ответ
MainMenu
Файл отображается в дереве проекта.

master
Это возможное имя ветки, и его в дереве проекта нет.

public static void main
Это часть файла, его нет в дереве проекта.
Как вам задача?


Способы запуска кода проекта
Потренируйтесь запускать код проекта изученными в видео способами.
Какая комбинация клавиш используется для автоформатирования кода в IntelliJ IDEA?


Ctrl + S / Cmd + S
Это команда для сохранения изменений.

Ctrl + F / Cmd + F
Это команда для поиска.

Правильный ответ
Ctrl + Alt + L / Cmd + Option + L
Это команда для форматирования.

Ctrl + Shift + F / Cmd + Shift + F
Это команда для поиска в файлах.
Как вам задача?


В чем различие между запуском кода напрямую, из окна редактирования, и запуском с конфигурацией?


Нет никакого различия
Отличия есть – конфигурация позволяет добавлять дополнительные настройки.

Правильный ответ
Запуск с конфигурацией позволяет задать параметры выполнения, например, аргументы командной строки

Правильный ответ
Запуск с конфигурацией может включать специфичные настройки для конкретного проекта или задачи

Запуск с конфигурацией требует дополнительного плагина
Это встроенный в IDEA инструмент.
Как вам задача?


Обработка ошибок компиляции
Запустите код из проекта и определите, какие ошибки компиляции из перечисленных ниже в нем есть


Правильный ответ
Пропущена точка с запятой
Одна из самых частых ошибок при программировании!

Правильный ответ
Пропущены скобки
В Java для условия if всегда нужны круглые скобки.

Правильный ответ
Пропущены кавычки
System.*out*.println(…) не может ни принять строку, ни прочитать данные в скобках как переменные или методы.

Неправильный ответ
Два «равно» вместо одного
Тут всё корректно – сравнение происходит именно так.

Тоже правильный ответ
Для if использованы квадратные скобки вместо круглых
В Java для условия if всегда нужны круглые скобки.

Тоже правильный ответ
Для индекса массива использованы круглые скобки вместо квадратных
Обращение к элементу массива происходит через квадратные скобки.
Как вам задача?


Дебаг
Какие баги из перечисленных ниже есть в проекте?


Правильный ответ
Счётчик увеличивается некорректно
После добавления элемента счётчик увеличивается на 10 вместо 1.

Правильный ответ
Список выводится с нумерацией от 1, а удаление – в нумерации от 0
Не хватает уменьшения на 1 при вызове метода removeTask.

Неправильный ответ
Некорректно объявлены начальные значения переменных
Все значения указаны верно.

Цикл бесконечен и его нельзя прервать
Цикл прерывается командой 4.
Как вам задача?


Использование подсказок в IDEA
Чтобы потренироваться вместе с видео, вы можете использовать этот проект.
Какие действия можно предпринять в случае возникновения следующей ошибки?

if (MAX_TASKS < 15) {
} 
Подсказка в IDEA: 'if' statement has empty body


Правильный ответ
Добавить в тело if выполнимый код.
Это корректный способ устранения ошибки, предполагающий, что условие должно выполнять какую-либо логику.

Удалить {}.
Ошибка никуда не денется.

Тоже правильный ответ
Удалить конструкцию if, если она не нужна.
Если условие не выполняет никакой полезной функции, лучше его удалить для улучшения читаемости кода.

Заменить if на while.
Такая замена не решает проблему и может привести к бесконечному циклу.
Как вам задача?


Какие действия можно предпринять в случае возникновения следующей ошибки?

private int someVariable; 
Подсказка в IDEA: Private field 'someVariable' is never used


Правильный ответ
Дописать код, чтобы использовать переменную в классе.
Это корректный способ устранения ошибки, предполагающий, что переменная всё-таки должна использоваться в логике программы.

Тоже правильный ответ
Удалить переменную, если она действительно не используется.
Если переменная не выполняет никакой полезной функции, лучше её удалить для улучшения читаемости кода.

Переименовать переменную.
Если переменная не выполняет никакой полезной функции, лучше её удалить для улучшения читаемости кода.
Как вам задача?


Какие действия можно предпринять в случае возникновения следующей ошибки?

int a;
int b;
if (10 > 15) {
    System.out.println("Кстати, 10 больше 15.");
    a = 5;
} 
Подсказка в IDEA: Condition '10 > 15' is always 'false’


Правильный ответ
Удалить блок if, если условие никогда не выполняется и код внутри блока не нужен.
Если условие и код в блоке if никак не влияют на выполнение программы, лучше их удалить для улучшения читаемости кода.

Правильный ответ
Пересмотреть логику условия.
Это необходимо, если условие должно проверять другой сценарий или содержит логическую ошибку.

Неправильный ответ
Добавить блок else для обработки случая, когда условие ложно.
В данном случае блок else будет выполняться всегда, поэтому корректнее добавить только ту логику, которая содержалась бы в блоке else.
Как вам задача?


Создание нового проекта
Какое название у данного элемента интерфейса?



Правильный ответ
Конфигурации запуска проекта
Этот пункт меню позволяет выбрать, что именно нужно запустить и настроить конфигурацию для запуска.

Окно проекта

Окно редактирования кода

Открытые вкладки для редактирования кода
Как вам задача?


Какое название у данного элемента интерфейса?



Конфигурации запуска проекта

Окно проекта

Правильный ответ
Окно редактирования кода
Этот элемент интерфейса позволяет редактировать открытый файл.

Открытые вкладки для редактирования кода
Как вам задача?


Какое название у данного элемента интерфейса?



Конфигурации запуска проекта

Окно проекта

Окно редактирования кода

Правильный ответ
Открытые вкладки для редактирования кода
Этот элемент интерфейса позволяет быстро переключаться между файлами, над которыми идёт работа.
Как вам задача?


Какое название у данного элемента интерфейса?



Конфигурации запуска проекта

Правильный ответ
Окно проекта
Позволяет смотреть всю иерархию проекта и открывать/изменять необходимые файлы.

Окно редактирования кода

Открытые вкладки для редактирования кода
Как вам задача?


Какие ошибки IntelliJ IDEA может обнаружить еще до запуска программы?


Правильный ответ
Синтаксические ошибки (англ. Syntax Errors)
Это ошибки, возникающие из-за неправильного использования конструкций языка программирования.

Неправильный ответ
Ошибки времени выполнения (англ. Runtime Errors)
Ошибки, которые возникают во время выполнения программы, например, из-за обращения к несуществующему объекту. Такие ошибки возникают уже после того, как программа запущена. До запуска IDEA может только подсветить те места, где такая ошибка потенциально может возникнуть.

Правильный ответ
Ошибки компиляции (англ. Compilation Errors)
Это ошибки, обнаруживаемые компилятором на этапе компиляции кода, до его выполнения.

Логические ошибки (англ. Logical Errors)
Это ошибки в логике программы, из-за которых программа выполняется не так, как ожидалось, но без сбоев в работе. Отследить такие ошибки бывает крайне трудно.
Как вам задача?


Каким образом использование System.out.println может помочь в поиске багов в Java?


Путём автоматического исправления синтаксических ошибок в коде.
К сожалению, такого добиться с помощью System.out.println не получится.

Правильный ответ
Путём вывода значений переменных, состояний объектов или результатов выполнения определённых участков кода в консоль
Такой подход позволяет отслеживать ход выполнения программы и обнаружить некорректное поведение.

Путём предотвращения возникновения исключений во время выполнения программы.
К сожалению, такого добиться с помощью System.out.println не получится.

Что вы узнали
Вот и подошёл к концу первый спринт. Теперь вы умеете запускать программы не только в тренажёре, но и на своём компьютере! А вот что ещё вы узнали в этой теме:
Для того чтобы сделать процесс разработки программ более удобным, программисты используют специальное приложение — интегрированную среду разработки (Integrated Development Environment, IDE).
Наиболее популярная IDE среди разработчиков на Java — IntelliJ IDEA. У неё есть бесплатная версия, доступная для загрузки.
У IntelliJ IDEA множество функций, в том числе удобный редактор кода, набор инструментов для проверки кода, его подготовки к выполнению и непосредственно выполнения, отладчик и анализатор кода.
Для того чтобы разрабатывать и запускать код на Java, требуется специальный набор программ — Java Development Kit (JDK). Самый простой способ установить JDK на компьютер — воспользоваться IntelliJ IDEA.
Компилятор — это специальная программа, переводящая код на языке Java, удобный для человека, в команды, которые может исполнять компьютер. Компилятор входит в состав JDK.
JDK содержит стандартную библиотеку Java — набор классов с готовыми решениями частых задач. Например, в неё входят классы String и Scanner.
Язык Java постоянно развивается, поэтому периодически выпускаются новые версии JDK. В этом курсе вы будете работать с Java 21.
Права на язык Java принадлежат корпорации Oracle, при этом существует несколько реализаций JDK, выпущенных различными компаниями. Вы можете использовать Amazon Coretto JDK — она бесплатная, к тому же её часто обновляют.