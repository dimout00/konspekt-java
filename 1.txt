Спринт 1
Сложные типы данных
Введение в тему
В ходе вводного курса вы поработали с переменными. Они позволяют хранить данные в программе — например, целые числа (int), дробные числа (double), строки (String), логические значения (boolean). Вы научились объявлять такие переменные, присваивать им значения и менять их, а также выполнять с ними арифметические операции.
?? Если вы забыли что-то из перечисленного, рекомендуем заглянуть в бесплатную часть курса. В ней содержатся базовые знания, без которых не получится двигаться дальше по темам.
За исключением String, все типы данных, которые вы изучили, являются простыми, или примитивными. Однако в реальных программах используют и другие.
Настало время поближе познакомиться с более сложными типами. Они могут не просто хранить определённые значения, но и совершать разные действия. В этой теме вы узнаете:
чем сложные типы данных отличаются от простых;
зачем нужен тип Scanner;
как создавать объекты сложных типов;
для чего нужны пакеты и как импортировать их в программу;
какие действия умеет совершать класс Scanner.
В конце темы будет много практики. Вы потренируетесь применять Scanner в программах, а также усовершенствуете финансовое приложение из вводного курса.

Сложные типы данных. Тип Scanner
В вводном курсе вы познакомились с такими типами данных в Java, как int, double, boolean. Это простые типы, их ещё называют примитивными.
Всё, что делают примитивные типы данных, — хранят в себе значение, которое можно в них записать и из них прочитать. Например:

 int x = 5 
Здесь мы сохранили в переменную с именем x значение, равное 5.
Кроме простых типов данных, в Java существуют сложные типы. Они позволяют добавить в программы много новых возможностей. В этом уроке вы узнаете о сложных типах больше.
Что такое сложный тип данных. Тип Scanner
Сложные типы в Java называют классами. Значения таких типов — это объекты классов, которые умеют выполнять определённые действия.
С одним из сложных типов данных вы уже сталкивались — это тип String. Он представляет собой объект-строку. Обратите внимание: в отличие от названий примитивных типов, названия сложных пишут с заглавной буквы.
Сложные типы можно создавать самостоятельно, и дальше в курсе мы расскажем, как это делать. Но в Java также есть много встроенных классов для решения самых разных задач — к ним относится и String.
Остановимся на ещё одном сложном типе. Тип Scanner представляет собой объект-читатель. Такой объект позволяет считывать из консоли данные, которые вводит пользователь. Например, мы можем попросить пользователя ввести своё имя, а затем в программе будем обращаться к нему по этому имени. Разберём подробнее, как работать со Scanner.
Создание объектов сложных типов
Работа с объектами сложных типов отличается от работы с примитивными типами данных. Чтобы воспользоваться таким объектом, сначала его нужно создать.
Для создания объектов используют слово new (англ. «новый»). Например, чтобы создать новый объект типа Scanner и сохранить его в переменную с именем scanner, понадобится такая команда:

Scanner scanner = new Scanner(System.in); 
System.in указывает, что Scanner будет считывать значения из стандартного потока ввода, то есть из окна консоли. Здесь вы можете заметить сходство с System.out — только System.out соответствует стандартному потоку вывода.

Когда вы создавали строки, вы не использовали слово new и просто присваивали значение переменной:

String weather = "Сегодня холодно!"; 
Дело в том, что строка — это особый класс в Java. Строки часто используют в программах. Поэтому в язык добавили возможность, которая позволяет работать со строками чуть проще, чем с остальными объектами.
Например, новую строку можно создать через указание её значения в кавычках. Когда Java встречает кавычки в программе, она понимает, что в этом месте нужно создать новый объект-строку.
?? Создать строку с помощью new тоже можно, хотя это и не рекомендуется делать. В Java есть специальные механизмы, которые повышают эффективность программ. Чтобы такие механизмы работали корректно, строки следует создавать без использования new.
Выберите, какие утверждения относятся к примитивным типам, а какие — к сложным типам (классам).
Примитивные типы
Чтобы присвоить значение, указывают имя переменной и само значение
Чтобы присвоить значение, указывают имя переменной и само значение
Хранят простое значение
Хранят простое значение
Включают в себя типы int, double, boolean
Включают в себя типы int, double, boolean

Сложные типы (классы)
Значения нужно создавать через слово new
Значения нужно создавать через слово new
Могут не только хранить значение, но и выполнять действия
Могут не только хранить значение, но и выполнять действия
Включают в себя тип, который позволяет считывать из консоли значения, введённые пользователем
Включают в себя тип, который позволяет считывать из консоли значения, введённые пользователем
Включают в себя тип String
Включают в себя тип String
Название типа начинается с заглавной буквы
Название типа начинается с заглавной буквы

Правильных ответов: 8, неправильных ответов: 0.
Как вам задача?


Пакеты в Java. Команда import
В работе с классами есть ещё один нюанс. Код, который реализует внутреннюю логику класса, обычно располагают в отдельном файле. Когда мы хотим использовать такой класс в своей программе, нужно, чтобы программа нашла этот файл.
В Java файлы с классами хранятся в разных папках, которые называют пакетами. Напоминает структуру файлов на жёстком диске компьютера: фотографии помещают в папку с названием «Фото», а аудиофайлы — в папку «Музыка». Так организуют и код — только не по папкам, а по пакетам.
Класс Scanner хранится в пакете с названием java.util. Чтобы использовать этот тип, сначала его нужно импортировать (англ. import). Для этого следует указать пакет, где он находится, вместе с именем типа: import java.util.Scanner.
?? Файлы на компьютере могут храниться в папках и подпапках. Например, файл эпизод_1.avi может храниться по такому пути: видео/сериалы/классный сериал. Так и классы могут храниться в пакетах и подпакетах, названия которых разделяют точкой. В нашем случае класс Scanner хранится в пакете util (утилитарные классы), который входит в пакет java (классы стандартной библиотеки языка Java).

Импорт указывают в самом начале, перед именем класса, в котором вы пишете программу. Если этого не сделать, код не заработает и выдаст ошибку java: cannot find symbol (англ. «не могу найти символ»).
Полностью код для создания нового объекта Scanner будет выглядеть так:

// импортируем тип Scanner
import java.util.Scanner;

public class Practicum {

    public static void main(String[] args) {
        // объявляем переменную с типом Scanner
        Scanner scanner = new Scanner(System.in);
    }
} 
Чтобы использовать в программе тип String, его не нужно импортировать. Он находится в специальном пакете java.lang, который содержит самые важные классы в Java. Настолько важные, что пакет импортируется в каждую программу автоматически.
Выберите верные утверждения об импорте типов в Java.


Правильный ответ
Импортировать нужно только сложные типы вне пакета java.lang.
Примитивные типы и типы из пакета java.lang всегда доступны в программе.

Если при импорте указывается строка import java.util.Scanner;, это значит, что нужно создать папку java/util и поместить в неё код, который реализует логику Scanner.
Scanner уже реализован и является частью Java — вам не нужно ничего делать дополнительно, только брать и использовать!

Правильный ответ
Если при импорте указывается строка import java.util.Scanner;, это значит, что файл с кодом Scanner лежит внутри директории java и её поддиректории util.
Именно так работает иерархия пакетов!

Неправильный ответ
Если попытаться использовать класс Scanner и при этом не выполнить import, программа будет считывать случайные данные, а не те, которые ввёл пользователь.
В этом случае программа просто не запустится.

Методы классов. Методы Scanner
В прошлом уроке мы обозначили важнейшую особенность сложных типов: они не просто хранят значения, но и умеют совершать некоторые действия. Такие действия называют методами объекта.
Например, среди методов строки можно назвать следующие действия: «получить длину строки», «проверить, содержит ли строка определённую подстроку» и так далее.
В этом уроке покажем, как вызывать методы, а также расскажем, какие методы есть у класса Scanner.
Как вызвать метод
Чтобы вызвать метод объекта, нужно взять ранее созданный объект, добавить точку и указать название метода. После названия метода ставят круглые скобки. Например:

// создаём строку с текстом "Hello, world!"
String hello = "Hello, world!";
// вызываем у строки метод length()
int stringLength = hello.length(); 
В этом примере вызываем у строки hello метод length() (от англ. length — «длина»), который находит длину этой строки, и сохраняем результат в переменную с именем stringLength.
Методы Scanner
Основное назначение объекта типа Scanner — считывание данных, которые пользователь ввёл в консоли. Для этого у Scanner есть целый набор методов. Каждый из них позволяет считать определённый тип данных.
Например, чтобы прочитать из консоли целое число (int), используют метод nextInt():

import java.util.Scanner;  // начинаем с импорта типа Scanner

public class Practicum {

    public static void main(String[] args) {
        // объявляем переменную с типом Scanner
        Scanner scanner = new Scanner(System.in);

        // считываем число
        int number = scanner.nextInt();
    }
} 
Запись scanner.nextInt() в коде означает, что у объекта scanner мы вызываем метод nextInt(). Значение, которое nextInt() прочитает из консоли, будет записано в переменную с именем number.
Усложним программу. Сделаем так, чтобы она запрашивала у пользователя два числа и выводила на экран их сумму:

import java.util.Scanner;

public class Practicum {

    public static void main(String[] args) {
        // объявляем переменную с типом Scanner
        Scanner scanner = new Scanner(System.in);

        System.out.println("Введите первое число:");
        // считываем первое число
        int number1 = scanner.nextInt();

        System.out.println("Введите второе число:");
        // считываем второе число
        int number2 = scanner.nextInt();

        // складываем числа и выводим результат
        int sum = number1 + number2;
        System.out.println("Сумма чисел: " + sum);
    }
} 
В примере вызываем метод nextInt() дважды, чтобы считать два числа. Результат его работы сохраняем в две переменные, number1 и number2, которые затем используем для вычисления суммы.
Если нужно прочитать не целое, а дробное число (double), используют метод nextDouble(). Принцип его использования аналогичен принципу применения nextInt().
Что нужно вставить вместо многоточий, чтобы получить код, который считывает дробное число?

... price = scanner....; 


int и nextInt()
Нужно считать дробное число, поэтому nextInt() не подойдёт.

int и nextDouble()
nextDouble() считывает дробное значение — его нужно записать в переменную соответствующего типа.

Правильный ответ
double и nextDouble()
Считываем дробное значение и сохраняем в переменную типа double.

double и nextDouble(price)
При вызове nextDouble() нужно указать пустые круглые скобки.
Как вам задача?


Часто нужно прочитать не отдельное число, а целую строку. Допустим, можно попросить пользователя ввести название его любимого напитка и на основе этого отобразить ему персональное промопредложение. Для чтения строки используют метод nextLine():

import java.util.Scanner;

public class Practicum {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("Введите свой любимый напиток:");
        String drinkName = scanner.nextLine();
        System.out.println("Мы узнали, что ваш любимый напиток — " + drinkName + ". Дарим вам кружку в подарок!");
    }
} 
Здесь с помощью метода nextLine() считываем из консоли название напитка и сохраняем в переменную drinkName, которую затем используем внутри текста сообщения.
Ещё один метод Scanner — это next(). Он позволяет прочитать не целую строку, а её часть до ближайшего пробела. Например, если в предыдущем примере любимым напитком пользователя оказался горячий шоколад, то nextLine() прочитает оба слова, а next() — только горячий.
Все рассмотренные методы Scanner отображены в таблице ниже.
| Название метода | Что читает | Пример ввода | Пример результата |
| --- | --- | --- | --- |
| `nextInt()` | целое число | 10 | 10 |
| `nextDouble()` | дробное число | 4.5 | 4.5 |
| `nextLine()` | строка (до символа переноса строки) | Привет, мир! | Привет, мир! |
| `next()` | часть строки (до пробела) | Привет, мир! | Привет, |
Практикум
Воспроизведём последовательность действий, которые нужны для считывания ввода пользователя.
С чего следует начать, чтобы научить программу считывать пользовательский текст?
Дмитрий
Выполнить импорт: java.util.Scanner;
Практикум
Недостаточно просто импортировать тип Scanner, нужно подготовить объект этого типа. Как это сделать?
Дмитрий
Создать Scanner с помощью new Scanner(System.in)
Практикум
А теперь выберите то самое важное действие, ради которого вы подключили и настроили Scanner.
Дмитрий
Прочитать текст с помощью nextLine()
Практикум
Замечательно: благодаря Scanner ваши программы станут ещё интереснее и смогут реагировать на действия пользователей!
Как вам задача?


Супер! Вы познакомились с основными методами для работы со Scanner. Пришло время попрактиковаться в их применении на тренежёре! Но перед этим разберёмся, как он работает.
Что такое тренажёр
Тренажёр — это наша внутренняя среда разработки, в которой вы будете писать код и закреплять полученные навыки. Благодаря тестам, написанным специально для проверки каждого задания, тренажёр проверяет ваше решение и подсветит строки, в которых была допущена ошибка.
Как работает тренажёр
В тренажёре вы пишете код, и он автоматически проверяется на корректность. За кадром запускаются заранее подготовленные тесты — они проверяют, правильно ли работает ваше решение.
Чтобы даже самая простая программа заработала и запустилась, требуется большое количество дополнительного кода, который вы научитесь писать в будущих уроках. Но для того, чтобы вы могли освоить базовые конструкции языка программирования, тренажёр устроен так, что код, выполняющий проверку решённой задачи, скрыт от вас. Таким образом, вам нужно написать только то, что требуется в задании.
Ошибки — человекочитаемые
Почти у каждой ошибки есть пояснение, которое позволит вам разобраться, что нужно поправить. Вместо стандартных технических формулировок вроде IndexOutOfBoundsException, которые обычно выводит в консоль компилятор, вы увидите адаптированные пояснения, например:
Кажется, вы обращаетесь к элементу, которого нет в массиве.
Так вы сразу увидите, почему в вашем решении появилась ошибка, и сможете её исправить, сосредоточившись только на конкретном элементе кода.
Возможны ограничения
Иногда сообщения об ошибках могут казаться не совсем точными. Всё дело в том, что на этапе работы с тренажёром ваше решение проверяется автоматически. Учитывайте, что решений может быть много, но в программу заложено ограниченное число вариантов реализации. Поэтому даже корректный код может не пройти все проверки, если его фрагменты отличаются от того, что от вас ожидает тренажёр.
Если вы уверены, что ваше решение верное, внимательно прочитайте текст ошибки и подсказку — они помогут немного скорректировать код так, чтобы он соответствовал тому варианту, который тренажёр использует для проверки.
На этом этапе вы осваиваете базовые шаблоны и подходы, но позже, по мере продвижения по курсу, у вас будет больше свободы: вы сможете предлагать собственные варианты, и их будут проверять живые ревьюеры с учётом разных подходов и стилей кода.
Что делать, если сообщение об ошибке не помогло
Внимательно прочитайте текст ошибки. Мы постарались сделать его максимально полезным. Например, вот как может выглядеть сообщение об ошибке в одном из заданий:
Задача прошла 0/1 проверок. Возможные проблемы:
— Измените значения полей класса
Ошибку спровоцировал такой код:

public static void main(String[] args) {
    Hamster homka = new Hamster();
    [homka.name](http://homka.name/) = "Хомка";
    homka.age = 420;
    homka.weight = 1;
    homka.color = "Черный";
} 
А вот как выглядит задание:
Отредактируйте вес хомяка. Поменяйте значение на «420»
Ошибка, которую получил студент, произошла из-за того, что вместо значения переменной weight, было изменено значение переменной age. Такие ошибки встречаются достаточно часто, именно поэтому стоит несколько раз внимательно себя перепроверять.

Что вы узнали
Ура! Первая тема позади. Вы познакомились со сложными типами данных и научились работать с одним из их представителей — Scanner. Коротко подытожим:
В отличие от примитивных типов, сложные типы (классы) не просто хранят значения, но могут совершать определённые действия.
Тип Scanner позволяет считывать данные, которые вводит пользователь в консоли. Этот результат можно сохранить в переменную и работать с ним дальше в программе.
Чтобы использовать сложные типы, их сначала нужно импортировать. Для этого следует указать пакет, где находится тип, вместе с его именем, например: import java.util.Scanner.
Для создания объектов классов используют слово new. Например, чтобы создать объект класса Scanner, нужна команда Scanner scanner = new Scanner(System.in).
Строки (String) очень часто используют в программах, но работа с ними происходит немного иначе. Чтобы создать строку, нужно просто указать её значение в кавычках — при этом импортировать тип String не нужно.
Чтобы считывать данные пользователя из консоли, у Scanner есть целый ряд методов, например: nextInt() и nextDouble() для чтения целых и дробных чисел, nextLine() и next() для чтения строк.
Теперь вы сможете использовать Scanner, если в вашей программе нужно поработать с данными, которые вводят пользователи!

Введение в тему
Вы уже познакомились с циклами в бесплатной части нашего курса. Знаете, что они позволяют выполнять повторяющиеся действия. Делают код компактным, а структуру программы более понятной. 
Напомним, циклы бывают разных типов. Вы изучили один из часто используемых циклов в Java — for. Он используется, когда известно, сколько будет повторений. Цикл for позволяет выполнять определённый блок кода несколько раз, изменяя значение переменной на каждой итерации. В нём можно указать начальное значение переменной, условие продолжения цикла и шаг изменения переменной.
?? Перед прохождением этой темы советуем ещё раз обратиться к урокам бесплатной части. Достаточно повторить только третью тему — «Циклы». Так вам будет легче разобраться в новом материале.
В этой теме вы продолжите изучать циклы. Вы узнаете:
что такое вложенные циклы и как их писать;
какие задачи решает цикл while;
для чего применяется бесконечный цикл.
В конце темы вы закрепите полученные знания, прокачав финансовое приложение. Вы научите его давать пользователю советы, чтобы он мог грамотно распорядиться своими деньгами.

Вложенные циклы
Для выполнения повторяющихся задач, требующих более сложной логики, используются вложенные циклы. Они нужны, когда внутри одного цикла требуется выполнить ещё один цикл. Например, чтобы перебрать ячейки таблицы, нужно для каждой строки пройтись по всем столбцам, одним циклом не обойтись.
В этом уроке разберём, как создавать вложенные циклы, и продолжим писать приложение для тренировок хомяка Байта. 
Как работает вложенный цикл
В вводном курсе вы начали писать программу тренировок для Байта, используя цикл for и условие внутри цикла. Напомним, её код выглядел так:

public class Practicum {
    public static void main(String[] args) {
        for (int i = 1; i <= 5; i++) {
            System.out.println("Круг " + i);

            if (i % 2 == 0) {
                System.out.println("Качаем пресс");
            } else {
                System.out.println("Отжимаемся ");
            }
            System.out.println("Бегаем в колесе");
        }
        System.out.println("Отлично позанимались сегодня! Вы - молодец!");
    }
} 
Байту очень понравилось это приложение, но он решил не останавливаться на достигнутом и просит запрограммировать для него ещё и расписание пробежек в колесе. Байт хочет следующие три дня тренироваться по два раза — утром и вечером. Нужно учесть эти два параметра: число тренировочных дней и количество пробежек в день, и запрограммировать вот такое расписание:

День 1
  Пробежка 1
  Пробежка 2
День 2
  Пробежка 1
  Пробежка 2
День 3
  Пробежка 1
  Пробежка 2 
Попробуем справиться с помощью обычного цикла for с шагом в единицу:
Код

JAVA

1
public class Practicum {
2
    public static void main(String[] args) {
3
        int days = 3; //число дней с тренировками
4
        for (int i = 1; i <= days; i++) {
5
            System.out.println("День " + i); // смена дней происходит в цикле
6
            System.out.println("  Пробежка 1");
7
            System.out.println("  Пробежка 2");
8
        }
9
    }
10
}
11
?




Запустить код
Результат

День 1

  Пробежка 1

  Пробежка 2

День 2

  Пробежка 1

  Пробежка 2

День 3

  Пробежка 1

  Пробежка 2
Вроде получилось?! Дни тренировок теперь сменяются в цикле. Однако чтобы отображались пробежки, пришлось дублировать код, а как вы помните, есть профессиональное правило — DRY. Получается, тренировки Байта тоже должны быть в цикле. И так как известно их точное число, используем цикл for.

Таким образом, нужно, чтобы в цикле для смены дней запускался цикл с пробежками. То есть внутри одного цикла оказывается другой — именно он называется вложенным. В коде это выглядит так:
Код

JAVA

1
public class Practicum {
2
    public static void main(String[] args) {
3
?
4
        int days = 2; // количество дней, в которые Байт будет тренироваться
5
        int run = 4; // число пробежек в день
6
?
7
        for (int i = 1; i <= days; i++) { // внешний цикл для смены дней
8
            System.out.println("День " + i);
9
            for (int j = 1; j <= run; j++) { // вложенный цикл для пробежек с новой переменной
10
                System.out.println("  Пробежка " + j);
11
            }
12
        }
13
    }
14
}




Запустить код
Результат

День 1

  Пробежка 1

  Пробежка 2

  Пробежка 3

  Пробежка 4

День 2

  Пробежка 1

  Пробежка 2

  Пробежка 3

  Пробежка 4
Логика кода следующая: сначала запускается внешний цикл, считающий дни. Программа печатает, что наступил первый день тренировки. После этого срабатывает вложенный цикл с пробежками —  совершает две итерации и завершается. Снова запускается внешний цикл — наступил второй день тренировки. И так далее. **В результате вы получите то самое расписание тренировок, которое попросил у вас Байт, при этом копирования кода не потребовалось. 
Попрактикуйтесь. Измените значение переменных run и days — и посмотрите, как много разных тренировочных программ вы можете составить для Байта. 
?? Обратите внимание, переменную итерирования чаще всего называют i. Это не строгое правило, вы можете дать ей любое имя, но i  — самое популярное. Для вложенного цикла, в свою очередь, самое распространённое имя —j.
С понедельника вы твёрдо решили заняться английским. Чтобы прокачать свой уровень, вы планируете в течение 30 дней смотреть в день по три серии любого сериала на английском. Допишите код внешнего и вложенного циклов, исходя из этих вводных:
Код

JAVA

1
public class Practicum {
2
    public static void main(String[] args) {
3
?
4
        for (int i = 1; i <= 30; i++) { 
5
            System.out.println("День " + i);
6
            for (int j = 1; j <= 3; j++) { 
7
                System.out.println(" Серия " + j);
8
            }
9
        } 
10
        System.out.println("Ура! Вы прокачали и Java, и английский!");
11
    }
12
}
Отличная работа! Умение создавать вложенные циклы ещё не раз вам пригодится.


Подсказка





Проверить
Циклы с несколькими уровнями вложенности
Вложенные циклы — удобный инструмент. Границ нет — можно «вкладывать» один цикл в другой сколько угодно раз. Давайте усложним тренировочную программу Байта, добавив в неё правила питания. Хомяк не щадит себя на тренировках, поэтому после пробежки в колесе ветеринар разрешил ему съедать по пять морковок. Это можно отразить, добавив в код второй вложенный цикл.
Код

JAVA

1
public class Practicum {
2
    public static void main(String[] args) {
3
?
4
        int days = 3; // количество дней, когда Байт будет тренироваться
5
        int run = 2; // число пробежек в день
6
        int carrots = 5; // число морковок после пробежки
7
?
8
        for (int i = 1; i <= days; i++) { // внешний цикл для смены дней
9
            System.out.println("День " + i);
10
?
11
            for (int j = 1; j <= run; j++) { // вложенный цикл для пробежек
12
                System.out.println(" Пробежка " + j);
13
                  System.out.println(i);
14
                for (int k = 1; k <= carrots; k++) { // ещё один вложенный цикл для морковок
15
                  System.out.println("  Морковка " + k);
16
                  System.out.println(i);
17
                  System.out.println(j);
18
?
19
                }
20
            }
21
        }
22
        System.out.println("Самое время спеть: всё идет по планууу!");
23
    }
24
}




Запустить код
Результат

День 1

 Пробежка 1

1

  Морковка 1

1

1

  Морковка 2

1

1

  Морковка 3

1

1

  Морковка 4

1

1

  Морковка 5

1

1

 Пробежка 2

1

  Морковка 1

1

2

  Морковка 2

1

2

  Морковка 3

1

2

  Морковка 4

1

2

  Морковка 5

1

2

День 2

 Пробежка 1

2

  Морковка 1

2

1

  Морковка 2

2

1

  Морковка 3

2

1

  Морковка 4

2

1

  Морковка 5

2

1

 Пробежка 2

2

  Морковка 1

2

2

  Морковка 2

2

2

  Морковка 3

2

2

  Морковка 4

2

2

  Морковка 5

2

2

День 3

 Пробежка 1

3

  Морковка 1

3

1

  Морковка 2

3

1

  Морковка 3

3

1

  Морковка 4

3

1

  Морковка 5

3

1

 Пробежка 2

3

  Морковка 1

3

2

  Морковка 2

3

2

  Морковка 3

3

2

  Морковка 4

3

2

  Морковка 5

3

2

Самое время спеть: всё идет по планууу!
При объявлении нескольких вложенных циклов не забудьте, что переменная итерирования каждого из них должна называться по-своему. Если вы назовёте их одинаково, то программа выдаст ошибку. Также важно помнить об областях видимости таких переменных: они видны в блоке своего цикла и вложенных в него, а за пределами этих циклов — нет. То есть в нашем примере переменная i  видна во всех трёх циклах, а переменная k — только внутри цикла с морковками. 
Поэкспериментируйте с переменными итерирования — измените их имена и проверьте области видимости. Например, добавьте в тело вложенного цикла значение переменной из внешнего и наоборот.

Цикл while
Вы много узнали о цикле for — он подходит для тех случаев, когда заранее известно количество итераций. Но так бывает не всегда. К примеру, студент будет читать учебник, пока не устанет. Он может осилить три главы, а может — семь.
Такой цикл можно описать с помощью служебного слова while. В переводе с английского это означает «до тех пор, пока». Например, «пока студент не устанет, он будет читать книгу». 
В этом уроке вы узнаете о цикле while. Разберём принципы его работы и рассмотрим ситуации, когда он может пригодиться.
Из чего состоит цикл while
В цикле for была переменная итерирования, условие и шаг цикла. Например,  for (int i = 1; i <= 10; i = i + 1).
В цикле while неизвестно число итераций: не получится задать ни переменную, ни шаг. Известно только условие, при котором цикл будет работать. Его и нужно указать.
Вот пример. Представь, что в баке автомобиля есть топливо. Когда оно закончится, нужно ехать на заправку. А пока не закончилось — вычитать из общего количества литр.
Вот и условие: пока бензин не закончился — while (liters > 1). В программе цикл будет выглядеть так.

Цикл будет работать, пока значение переменной liters больше 1 — в баке есть хотя бы литр бензина. Как только переменная станет равна 1, цикл завершится.
После этого можно напечатать предупреждение, что пора заправиться:

int liters = 50;// Литры топлива 
while (liters > 1) {// Условие работы цикла - пока остался хотя бы 1 литр бензина
    liters = liters - 1;// Тратим 1 литр бензина за раз
}

System.out.println("Бензин почти закончился! Пора на заправку!"); 
Применяем цикл while на практике
Допустим, вы закупили для Байта корм впрок — неизвестно, как быстро хомяк всё съест. Нужно подсчитать количество порций. В таком случае работа цикла будет определяться не числом повторений, а булевым выражением — питомец ест корм до тех пор, пока он в наличии. Если корм кончился — булево выражение стало ложным — цикл завершится. Такой цикл описывается с помощью служебного слова while (от англ. while — до тех пор, пока).
В цикле for мы определяли переменную итерирования, условие и шаг цикла. В цикле while нам неизвестно число итераций, поэтому не получится задать ни переменную, ни шаг. Мы знаем только условие его работы. Его и указываем после слова while, перед телом цикла в фигурных скобках:

int foodWeight = 500; // количество корма

while (foodWeight > 10) { // условие работы цикла - пока осталась хотя бы одна порция
    foodWeight = foodWeight - 10; // Байт съедает 10 грамм корма за раз
}

System.out.println("Корм почти закончился! Пора идти в магазин!"); 
Структура циклов for и while похожа, как и логика их работы — цикл выполняется, пока условие верно. В нашем примере цикл while будет работать до тех пор, пока значение переменной foodWeight больше 10 — дома есть хотя бы одна порция корма. Как только переменная станет равна 10 — цикл завершится. После этого будет выполнен следующий код — напечатано предупреждение, что пора идти в магазин.

Какие задачи из списка ниже можно было бы описать с помощью цикла for, а какие с помощью while?
while
Перемещать коробки на складе при условии, что за один подход можно взять одну коробку, а их общее количество каждый раз разное.
Перемещать коробки на складе при условии, что за один подход можно взять одну коробку, а их общее количество каждый раз разное.
Копить деньги на машину
Копить деньги на машину
Играть в казино
Играть в казино
Разгружать машину с вещами без их списка
Разгружать машину с вещами без их списка

for
Нарезать пиццу для семи коллег
Нарезать пиццу для семи коллег
Тренироваться по заранее составленному плану
Тренироваться по заранее составленному плану

Правильных ответов: 6, неправильных ответов: 0.
Как вам задача?


Когда использовать цикл while
Цикл while поможет, когда работа программы зависит от внешних данных, которые изначально неизвестны. Например, нужно прочитать книгу, но непонятно, сколько в ней страниц. Или нужно писать код, пока не устанешь: можно устать через 20 минут, а можно через час.

Цикл while также можно использовать для расчётов. К примеру, ваш друг хочет накопить 5000 рублей. Он не знает заранее, какую точно сумму сможет откладывать каждый день, но решил, что точно не больше 300 рублей. Эту задачу можно решить, соединив цикл while и генератор случайных чисел — Random. 
Генератор случайных чисел будет играть в коде роль вашего друга: определять число в диапазоне от 0 до 300 — именно столько денег будет отложено за день и сохранено в переменной moneyToday. Цикл while будет складывать эти деньги в копилку, суммируя их, и получать общую сумму накоплений moneyTotal. Одновременно while посчитает количество дней dayCount — то есть сколько итераций совершил цикл (сколько случайных чисел сгенерировал Random), чтобы получилось 5000. Это выглядит так:
Код

JAVA

1
import java.util.Random; 
2
?
3
public class Practicum {
4
    public static void main(String[] args) {
5
        Random random = new Random(); // генерирует случайное число
6
?
7
        int dayCount = 0; // для учёта дней накоплений
8
        int moneyTotal = 0; // суммарное количество накоплений
9
        int moneyToday; // сколько откладываем сегодня
10
        int goal = 5000; // финансовая цель
11
?
12
        while (moneyTotal <= goal) {
13
            moneyToday = random.nextInt(300); // случайная сумма на сегодня
14
            moneyTotal = moneyTotal + moneyToday; // добавили эти деньги в копилку
15
            dayCount = dayCount + 1; // засчитали день
16
            System.out.println("Денег " + moneyTotal + " per day " + dayCount + " today " + moneyToday);
17
        }
18
?
19
        System.out.println("Ура! Вы смогли накопить " + goal + " за " + dayCount + " дней.");
20
    }
21
}




Запустить код
Позапускайте код и посмотрите, за сколько дней наберётся нужная сумма. Удастся ли вашему другу достичь своей финансовой цели за месяц? А за два?
Цикл while удобно использовать, когда работа программы зависит от внешних данных, которые изначально неизвестны, — например, их вводит пользователь. Допустим, вы разрабатываете приложение-тренажёр по математике. Предполагается, что пользователь должен решать примеры с экрана и вводить свои ответы. Если ответ неправильный, то требуется повторять пример снова и снова — это и обеспечит терпеливый цикл while. В случае правильного ответа цикл завершится. 
Посмотрим, как это будет выглядеть в коде. Возьмём простой пример «Сколько будет 2+3?» и создадим цикл while, который будет предлагать пользователю решить его. Нужно, чтобы цикл выполнялся до тех пор, пока не введён правильный ответ, равный 5. Чтобы отразить это в условии цикла, потребуется логический оператор «не равно» —!=.
Кроме того, для считывания ответа понадобится Scanner — введённое с консоли число будет храниться в переменной x. Таким образом, условие работы цикла получится таким — x != 5. Соединяем всё это:


Scanner scanner = new Scanner(System.in); // позволяет считать ответ пользователя
int x = 0; // хранит ответ пользователя

while (x != 5) { // цикл выполняется, пока х не равна 5
    System.out.println("Сколько будет 2+3?");
    x = scanner.nextInt(); // считываем из консоли число и присваиваем переменной х
}
System.out.println("Пример решён правильно!");
 
В переменную x сохраняется число, которое вводит пользователь. Сначала ей присвоено значение 0 — пользователь ещё не ввёл ничего, однако это нужно, чтобы цикл заработал. В теле цикла даём пример и считываем ответ пользователя с помощью выражения scanner.nextInt() — int внутри него означает, что нужно считать из консоли именно числовое значение (если ввести буквенное, строку — будет ошибка). 
Как только пример решён (ответ правильный, то есть условие ложно) — цикл завершится. Один из вариантов работы этого цикла может быть таким:

Сколько будет 2+3?
6
Сколько будет 2+3?
73
Сколько будет 2+3?
5
Пример решён правильно! 
Циклы, циклы, циклы. Кажется, что вы попали в цикл по изучению циклов! А вдруг это ещё и while — непонятно, сколько итераций впереди и условие «не сдаваться» уже скорее ложно, чем истинно? Спешим вас успокоить — если вы и в цикле, то определённо в for — количество теории и тренажёров строго ограничено!

Бесконечный цикл
С помощью while можно создать бесконечный цикл, то есть цикл, который будет повторяться неограниченное число раз. Такие циклы активно используются, например, при передаче данных, когда их объём неизвестен заранее. Или в построении web-приложений, которые общаются через не всегда надёжную сеть и могут «падать», и поэтому им требуется снова и снова отправлять друг другу запросы. 
При работе с пользователями бесконечные циклы нужны, чтобы обеспечить беспрерывное ожидание и обработку таких операций, как касание экрана, свайпы или ввод текста и других. 
В этом уроке вы узнаете, как создать бесконечный цикл, управлять им и останавливать его.  
while превращается в… бесконечный цикл!
Вам известно, что циклwhile выполняется до тех пор, пока условие истинно. Следовательно, если в условии написать true, то цикл будет выполняться снова и снова. Проверим это, продолжив улучшать приложение для тренировок. Напишем такой цикл для пробежки Байта в колесе.

while (true) { 
    System.out.println("Бегу, бегу, бегу!"); // будет выполняться бесконечно
}
 System.out.println("Отлично побегал!"); // эта строка не будет напечатана 
В консоли будет беспрерывно печататься строка "Бегу, бегу, бегу!", а до строки "Отлично побегал!" очередь никогда не дойдёт. Хомяк Байт в колесе превратится в вечный двигатель! Именно такой цикл, который начинается со служебного слова while и содержит в условии true, называется бесконечным. И никакого символа бесконечности ? не требуется — его просто-напросто нет в синтаксисе Java.
Если же написать в условии цикла false и попробовать запустить код, то вообще ничего не получится. Программа выдаст ошибку: unreachable statement (англ. «недостижимое утверждение»).

while (false) { 
    System.out.println("Никуда не побегу!"); // Такой цикл не запустится. Хомяк решил поспать.
} 

Как остановить цикл
Теперь разберёмся, как закончить цикл: Байт же не может вечно бегать в колесе. Выйти из бесконечного цикла можно двумя способами. Первый — остановить программу. Но это всё равно что сломать колесо — не очень практично. Более рационально использовать второй способ — добавить в код слово break (англ. «перерыв»). 
На break цикл сразу завершится, а программа перейдёт к выполнению следующего кода.  Это выглядит так:

while (true) { 
    System.out.println("Бегу, бегу, бегу!");
    break; // цикл завершился
}
System.out.println("Отлично побегал, пойду поем!"); // теперь эта строка будет напечатана 
В результате будет напечатано:

Бегу, бегу, бегу!
Отлично побегал, пойду поем! 
Ура! Байт сможет закончить пробежку и пойти перекусить. Свободу хомякам!
Выберите правильные варианты того, как создать бесконечный цикл?


Использовать for (int i = 0; i ? ?; i++)
Неверно, такого символа ? нет в синтаксисе Java.

Правильный ответ
Использовать while (true)
Верно! Условие здесь всегда истинно — цикл будет выполняться снова и снова.

Использовать while (?)
Неправильно! Символа бесконечности ? нет в синтаксисе Java.

Использовать for (int i = 0; i < 10000000000; i++)
Хорошая попытка, но нет. Цикл с таким условием не будет работать бесконечно.

Правильный ответ
Использовать while (1 == 1)
Условие этого цикла тоже всегда истинно, а значит, он будет работать бесконечно.

Использовать while (false)
Ошибочка вышла! Условие здесь всегда ложно — цикл вообще не запустится.
Как вам задача?


Иногда требуется завершить не цикл целиком, а только текущую итерацию. Например, если дальнейшие действия в ней не требуются. Представим, что Байт бегает каждый день, но не знает, сколько ему нужно пробежать сегодня. Если он получит команду, что нужно пробежать 0 шагов, то он может немного отдохнуть и отложить физическую активность на следующий день.
Чтобы настроить цикл, воспользуемся оператором continue. Если в теле цикла встречается continue, текущая итерация завершается и сразу начинается следующая: словно кода от continue до конца тела цикла не существует. Рассмотрим пример. 

Scanner scanner = new Scanner(System.in);
while (true) {
    System.out.println("Сколько сегодня бежать?");
    int steps = scanner.nextInt();
    if (steps == 0) {
        //бежать не нужно: выводим сообщение и переходим к следующей итерации
        System.out.println("Сегодня пробежка отменяется");
        continue;
    }
    System.out.println("Я пробежал " + steps + " шагов!");
} 
В том случае, если Байт получит указание бежать 0 шагов, строка с текстом “Я пробежал 0 шагов!” выведена не будет. Вместо этого можно сразу перейти к следующему вводу данных. Вывод такой программы может выглядеть следующим образом:

Сколько сегодня бежать?
3
Я пробежал 3 шагов!
Сколько сегодня бежать?
0
Сегодня пробежка отменяется
Сколько сегодня бежать?
5
Я пробежал 5 шагов!
... 
Когда нужно прервать цикл
Бесконечный цикл с прерыванием break нужен, когда требуется выполнять условно неограниченное количество итераций до достижения определённого результата. Например, при вызове такси в приложении радиус поиска свободной машины расширяется до тех пор, пока не найдётся первый подходящий автомобиль. Однако условий выхода из цикла (подходящих машин) может быть несколько, и в таком случае можно предложить пользователю выбор.

Как работает бесконечный цикл с break с несколькими условиями выхода, разберём на примере первого тренажёра этого урока. Переходите к нему!

Добавляем бесконечный цикл в финансовое приложение
Пришло время усовершенствовать финансовое приложение. Сейчас оно работает так: предлагает ввести баланс на счету в рублях и число дней до зарплаты, после чего просит выбрать команду convert или advice. В зависимости от команды программа либо конвертирует деньги в какую-то из доступных валют — доллары, евро или юани, либо дает совет, где сегодня поужинать. Код выглядит так:

import java.util.Scanner;

class Practicum {
    public static void main(String[] args) {
        double rateUSD = 94.8;
        double rateEUR = 103.8;
        double rateCNY = 13.1;

        Scanner scanner = new Scanner(System.in);

        System.out.println("Сколько денег у вас осталось до зарплаты?");
        double moneyBeforeSalary = scanner.nextDouble();

        System.out.println("Сколько дней до зарплаты?");
        int daysBeforeSalary = scanner.nextInt();

        System.out.println("Введите команду. Доступные команды: convert и advice.");
        String command = scanner.next();

        if (command.equals("convert")) {
            System.out.println("В какую валюту хотите конвертировать рубли? Доступные варианты: USD, EUR, CNY.");
            String currency = scanner.next();

            if (currency.equals("USD")) {
                System.out.println("Ваши сбережения в долларах: " + moneyBeforeSalary / rateUSD);
            } else if (currency.equals("EUR")) {
                System.out.println("Ваши сбережения в евро: " + moneyBeforeSalary / rateEUR);
            } else if (currency.equals("CNY")) {
                System.out.println("Ваши сбережения в юанях: " + moneyBeforeSalary / rateCNY);
            } else {
                System.out.println("Введена неизвестная валюта.");
            }

        } else if (command.equals("advice")) {
            if (moneyBeforeSalary < 3000) {
                System.out.println("Сегодня лучше поесть дома. Экономьте и вы дотянете до зарплаты!");
            } else if (moneyBeforeSalary < 10000) {
                if (daysBeforeSalary < 10) {
                    System.out.println("Можно заказать пиццу!");
                } else {
                    System.out.println("Сегодня лучше поесть дома. Экономьте и вы дотянете до зарплаты!");
                }
            } else if (moneyBeforeSalary < 30000) {
                if (daysBeforeSalary < 10) {
                    System.out.println("Неплохо! Сегодня можно поужинать в кафе.");
                } else {
                    System.out.println("Можно заказать пиццу!");
                }
            } else {
                if (daysBeforeSalary < 10) {
                    System.out.println("Отлично! Можно сходить в ресторан.");
                } else {
                    System.out.println("Неплохо! Сегодня можно поужинать в кафе.");
                }
            }
        } else {
            System.out.println("Извините, такой команды пока нет.");
        }
    }
} 
Основной недостаток, который бросается в глаза, — вводить команды словами неудобно, можно легко ошибиться. Нужно исправить код приложения таким образом, чтобы вместо слов он принимал числа. Конвертация валют должна срабатывать, если пользователь ввёл число 1, а выдача совета по поводу ужина — число 2. Для этого нам нужно внести изменения в следующие строки:

System.out.println("Введите команду. Доступные команды: convert и advice.");
String command = scanner.next();

if (command.equals("convert")) {
        ...
} else if (command.equals("advice")) {
        ...
} 
Для начала сделаем приложение более дружелюбным к пользователю: заменим призыв «Введите команду» на вопрос «Что вы хотите сделать?». Теперь с ним гораздо приятнее иметь дело. Далее создадим и оформим цифровое меню с двумя опциями: «1 — Конвертировать валюту» и «2 — Получить совет». 

 System.out.println("Что вы хотите сделать?");
 System.out.println("1 - Конвертировать валюту");
 System.out.println("2 - Получить совет"); 
Какой метод потребуется в коде финансового приложения, чтобы считать из консоли выбранный пользователем номер пункта цифрового меню?


scanner.next()
Нет, этот метод хорошо считывает из консоли одно слово из фразы до пробела.

Правильный ответ
scanner.nextInt()
Точно! Этот метод считывает из консоли целые числа, ровно такие же, как и пункты в цифровом меню.

scanner.nextDouble()
Неверно. Этот метод считывает числа с дробной частью, для обозначения пунктов в меню используются целые значения.

scanner.nextLine()
Нет, этот метод считывает строки, а нам необходимо считать целые числовые значения.

scanner.IntNext()
Кажется, тут что-то напутано. Сначала должно стоять next, а потом уже затем Int.

scanner.nextString()
А такого метода вообще нет в Java — мы его придумали! За считывание строк отвечает scanner.nextLine().
Как вам задача?


Теперь программа должна считать ответ пользователя из консоли. Раньше это происходило с помощью команды scanner.next(), однако теперь у нас не слова, а цифры, поэтому нужно использовать scanner.nextInt().

int command = scanner.nextInt(); 
Следующий шаг — отредактировать условия при выборе команд. Вместо слов здесь также будут цифры 1 или 2. Их нужно сравнить с переменной command при помощи оператора проверки на равенство  ==.

if (command == 1) {
        ...
} else if (command == 2) {
        ...
} 
Готово! Теперь у финансового приложения появилось цифровое меню, пользователю больше не нужно мучиться, набирая слова на клавиатуре. 
Однако есть небольшая проблема. Такой код будет работать, пока пользователь в ответ на вопрос вводит число. Но пользователи бывают невнимательны и могут ошибиться. Если ввести не число, а любую строку, программа выдаст ошибку:

Exception in thread "main" java.util.InputMismatchException 
  at java.base/java.util.Scanner.throwFor(Scanner.java:939) 
  at java.base/java.util.Scanner.next(Scanner.java:1594) 
  at java.base/java.util.Scanner.nextDouble(Scanner.java:2564) 
  at Practicum.main(Practicum.java:13) 
Эта ошибка называется исключением (англ. exception). Исключения возникают, когда программа уже запустилась, начала работать, но вдруг что-то пошло не так. Например, произошло деление на ноль, пользователь вместо числа ввёл строку, как в нашем примере, или попытался открыть файл, которого нет на компьютере. 
Важно научиться отличать исключение от синтаксической ошибки и понимать, из-за чего именно оно произошло. Для этого нужно внимательно прочитать сообщение в терминале. Главный маркер того, что перед вами именно исключение — само слово Exception. После него, в первой строке, указано его имя — InputMismatchException (англ. «несоответствие ввода»). На последней строке даётся расположение строки, где возникло исключение: Practicum.main, строка 13. Всегда внимательно читайте текст сообщений об ошибках — это поможет вам быстро разобраться с проблемой.
Что такое исключение?


Специальное обращение к переменной, которое применяется в особых случаях.
Такого в Java нет.

Правильный ответ
Сообщение об ошибке, которая возникла в ходе работы программы.
Всё верно. Исключения возникают уже в работающей программе и чаще всего сигнализируют об ошибках.

Когда программа не запускается и в консоли всё красное.
Это не исключение. Так чаще всего выглядят опечатки или синтаксические ошибки в коде.

Дополнительная ветка условия if, когда ни одно из условий не сработало.
Исключение никак не связано с условными выражениями.
Как вам задача?


Определите, где произошло исключение?

Exception in thread "main" java.util.InputMismatchException
    at java.base/java.util.Scanner.throwFor(Scanner.java:939)
    at java.base/java.util.Scanner.next(Scanner.java:1594)
    at java.base/java.util.Scanner.nextDouble(Scanner.java:2564)
    at PhoneBook.main(PhoneBook.java:22) 


Scanner.java, строка 939
Нет, это неправильный ответ. Место, в котором произошла ошибка, нужно искать в последней строке.

Practicum.main, строка 13
Нет, это расположение исключения из примера в уроке, здесь текст сообщения из терминала другой.)

Правильный ответ
PhoneBook.java, строка 22
Так держать! Теперь вы знаете, где именно в коде произошла ошибка.
Как вам задача?


У финансового приложения теперь есть цифровое меню и вас больше не напугать исключениями. Однако программа по-прежнему даёт выбрать только одну команду, а после её выполнения завершается. Это неудобно — возможно, пользователь захочет не только конвертировать деньги, но и получить совет, однако для этого ему придётся перезапускать приложение. Исправить это можно, если добавить в код бесконечный цикл while и предусмотреть возможность выхода из него, например при выборе цифры 0. Программа сможет работать так:

...
Что вы хотите сделать? 
1 - Конвертировать валюту
2 - Получить совет
0 - Выход
> 2
Можно заказать пиццу!
Что вы хотите сделать? 
1 - Конвертировать валюту
2 - Получить совет
0 - Выход
> 0
Выход 
Сейчас вам нужно завершить «прокачку» финансового приложения — добавить цифровое меню для выбора валюты при конвертации и с помощью бесконечного цикла сделать программу удобной для пользователя.

Что вы узнали
Поздравляем! Вы успешно справились с ещё одной темой. Теперь вы знаете всё о циклах! Коротко подытожим: 
Вложенные циклы — это циклы, которые находятся внутри других циклов. Они используются для выполнения повторяющихся задач, требующих более сложной логики.
Цикл while используется, когда неизвестно число итераций. Он поможет, если работа программы зависит от внешних данных, которые изначально неизвестны.
С помощью while можно создать бесконечный цикл, который будет повторяться неограниченное число раз.
Остановить бесконечный цикл можно с помощью слова break.
Циклы используются в большинстве программ. С их помощью можно избежать дублирования кода. Ещё они позволяют описать большое количество действий небольшим фрагментом кода. Некоторые задачи решить без циклов попросту невозможно. А это значит, что вы овладели мощным инструментом, который поможет вам писать полезные и сложные программы.



